{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Sandhill","text":"<p>Sandhill is an extensible platform designed to make developing data-driven web applications fast and easy. Written in Python using the Flask microframework, Sandhill is written to encourage a decoupled codebase that allows for rapid deployment of new features. It provides the tools to quickly combine multiple data sources into web content using customizable data processors.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Instance Setup</li> <li>Developing Your Instance</li> <li>Service Setup</li> <li>Functional Testing</li> <li>Development Guidelines</li> </ul>"},{"location":"#user-guide","title":"User Guide","text":"<ul> <li>Routes in Sandhill</li> <li>Data Processors in Sandhill</li> <li>Template Filters</li> <li>Bootstrap Process</li> <li>Evaluate Conditions</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"api-reference/","title":"Sandhill API Reference","text":"<p>This document provides API reference for Sandhill code not covered by the user documentation. If you plan on developing additional data processors, filters, or the like, this may be useful. Otherwise, you can safely ignore these documentation pages.</p>"},{"location":"api-reference/#routes","title":"Routes","text":"<p>Core routing API should not be needed even when developing new functionality for your instance. Still, it's provided here for the curious.</p>"},{"location":"api-reference/#sandhill.routes.static","title":"<code>sandhill.routes.static</code>","text":"<p>Sandhill overrides/additions to the  default Flask <code>/static</code> route.</p>"},{"location":"api-reference/#sandhill.routes.static.favicon","title":"<code>favicon()</code>","text":"<p>Wrapper to calling handle_static for the ever popular favicon file. </p> <p>Returns:</p> Type Description <code>file stream</code> <p>The favicon.ico file stream from inside <code>/static</code> </p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>On HTTP error</p> Source code in <code>sandhill/routes/static.py</code> <pre><code>@app.route('/favicon.ico')\ndef favicon():\n    '''\n    Wrapper to calling handle_static for the ever popular favicon file. \\n\n    Returns:\n        (file stream): The favicon.ico file stream from inside `/static` \\n\n    Raises:\n        HTTPException: On HTTP error \\n\n    '''\n    return handle_static('favicon.ico')\n</code></pre>"},{"location":"api-reference/#sandhill.routes.static.handle_static","title":"<code>handle_static(filename)</code>","text":"<p>Replacement for the default Flask <code>/static</code> path handler.     Retrieves the requested static file by first looking for it inside     the <code>instance/static/</code> directory. If the file is not found, this     method will then look for the file in the core <code>sandhill/static/</code>     directory. </p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The requested file path within <code>/static</code> </p> required <p>Returns:</p> Type Description <code>file stream</code> <p>File stream of the file object </p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>On HTTP error</p> Source code in <code>sandhill/routes/static.py</code> <pre><code>@app.route('/static/&lt;path:filename&gt;', endpoint='static')\ndef handle_static(filename):\n    '''\n    Replacement for the default Flask `/static` path handler. \\\n    Retrieves the requested static file by first looking for it inside \\\n    the `instance/static/` directory. If the file is not found, this \\\n    method will then look for the file in the core `sandhill/static/` \\\n    directory. \\n\n    Args:\n        filename (str): The requested file path within `/static` \\n\n    Returns:\n        (file stream): File stream of the file object \\n\n    Raises:\n        HTTPException: On HTTP error \\n\n    '''\n    # Return from instance/static/ if available\n    static_path = os.path.join(app.instance_path, \"static\")\n\n    # Fall back to sandhill/static/\n    if not os.path.isfile(os.path.join(static_path, filename)):\n        static_path = os.path.join(app.root_path, \"static\")\n\n    cache_timeout = app.get_send_file_max_age(filename)\n    return send_from_directory(static_path, filename, max_age=cache_timeout)\n</code></pre>"},{"location":"api-reference/#sandhill.routes.error","title":"<code>sandhill.routes.error</code>","text":"<p>Sandhill HTTP error handling</p>"},{"location":"api-reference/#sandhill.routes.error.handle_http_abort","title":"<code>handle_http_abort(exc)</code>","text":"<p>Overrides the default Flask template for abort codes. </p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>HTTPException</code> <p>A HTTPException from a 4xx or 5xx HTTP code </p> required <p>Returns:</p> Type Description <code>Response</code> <p>The Flask error response</p> Source code in <code>sandhill/routes/error.py</code> <pre><code>@app.errorhandler(HTTPException)\ndef handle_http_abort(exc):\n    \"\"\"\n    Overrides the default Flask template for abort codes. \\n\n    Args:\n        exc (werkzeug.exceptions.HTTPException): A HTTPException from a 4xx or 5xx HTTP code \\n\n    Returns:\n        (flask.Response): The Flask error response \\n\n    \"\"\"\n    # Check if the request accepts json format, if so prefer that for rendering\n    request_format = match_request_format(None, [\"application/json\", \"text/html\"])\n    if request_format == \"application/json\":\n        exc_dict = {\"code\": exc.code, \"name\": exc.name, \"description\": exc.description}\n        return jsonify(exc_dict), exc.code\n\n    # Otherwise return html\n    return render_template(\"abort.html.j2\", e=exc), exc.code\n</code></pre>"},{"location":"api-reference/#sandhill.routes.main","title":"<code>sandhill.routes.main</code>","text":"<p>The main route provides the entry point for Sandhill, loading and adding routes.</p>"},{"location":"api-reference/#sandhill.routes.main.add_routes","title":"<code>add_routes()</code>","text":"<p>Decorator function that adds all routes to the Flask app based     on JSON route configs loaded from <code>instance/configs/routes/</code>.</p> Source code in <code>sandhill/routes/main.py</code> <pre><code>def add_routes():\n    \"\"\"\n    Decorator function that adds all routes to the Flask app based \\\n    on JSON route configs loaded from `instance/configs/routes/`. \\n\n    \"\"\"\n    app.logger.debug(\"Processing routes.\")\n    def decorator(func, **options):\n        all_routes = get_all_routes()\n        app.logger.debug(f\"Loading routes: {', '.join([repr(route) for route in all_routes])}\")\n        for route in all_routes:\n            endpoint = options.pop('endpoint', None)\n            options['methods'] = route.methods\n            app.logger.debug(\n                f\"Adding URL rule: {route.rule}, {endpoint}, {func} {json.dumps(options)}\"\n            )\n            app.add_url_rule(route.rule, endpoint, func, **options)\n        return func\n    return decorator\n</code></pre>"},{"location":"api-reference/#sandhill.routes.main.main","title":"<code>main(*args, **kwargs)</code>","text":"<p>Entry point for the whole Sandhill application, handling all routes and     determining if a route has output to respond with after all processing     is completed. </p> <p>Based on the route_config that the path matches to, it will load all the     required data processors before rendering the result. </p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Unused </p> <code>()</code> <code>**kwargs</code> <p>Unused </p> <code>{}</code> <p>Returns:</p> Type Description <p>A valid response for Flask to render out, or raises HTTP 500</p> Source code in <code>sandhill/routes/main.py</code> <pre><code>@add_routes()\ndef main(*args, **kwargs): # pylint: disable=unused-argument\n    \"\"\"\n    Entry point for the whole Sandhill application, handling all routes and \\\n    determining if a route has output to respond with after all processing \\\n    is completed. \\n\n    Based on the route_config that the path matches to, it will load all the \\\n    required data processors before rendering the result. \\n\n    Args:\n        *args: Unused \\n\n        **kwargs: Unused \\n\n    Returns:\n        A valid response for Flask to render out, or raises HTTP 500 \\n\n    \"\"\"\n    route_used = request.url_rule.rule\n    ## loop over all the configs in the instance dir looking at the \"route\"\n    ## field to determine which configs to use\n    route_config = load_route_config(route_used)\n    ## process and load data routes\n    route_data = []\n    data = {}\n    ## if 'template' is in the route_config, append the template processor\n    ## to handle legacy configs\n    if 'template' in route_config:\n        if 'data' not in route_config:\n            route_config['data'] = []\n        route_config['data'].append(\n            {\n                'processor': 'template.render',\n                'file': route_config['template'],\n                'name': '_template_render'\n            })\n    route_rules = tolistfromkeys(route_config, 'route', 'routes')\n    if 'data' in route_config:\n        for idx, entry in enumerate(route_config['data']):\n            if 'name' in entry and 'processor' in entry:\n                route_data.append(entry)\n            else:\n                app.logger.warning(f\"Unable to parse route data entry number {idx} \" \\\n                                   f\"for: {1} {','.join(route_rules)}\")\n        data = load_route_data(route_data)\n    # check if none of the route processors returned a FlaskResponse\n    if not isinstance(data, (FlaskResponse, WerkzeugReponse)):\n        app.logger.warning(\n            f\"None of the 'data' processors in {route_rules}\"\n            f\" returned a Response object\"\n        )\n        if app.debug:\n            data = jsonify(data)\n        else:\n            abort(500)\n    return data\n</code></pre>"},{"location":"api-reference/#data-processors","title":"Data Processors","text":"<p>Sandhill routes are composed of a list of data processors. These are single actions that Sandhill may take while processing a request. See the data processor documentation for full details.</p>"},{"location":"api-reference/#utils","title":"Utils","text":"<p>Utilities are bits of helper code used elsewhere in Sandhill. Functions or classes in <code>utils/</code> may be useful in writing instance specific code for your Sandhill site.</p>"},{"location":"api-reference/#sandhill.utils.api","title":"<code>sandhill.utils.api</code>","text":"<p>Functionality to support API calls.</p>"},{"location":"api-reference/#sandhill.utils.api.api_get","title":"<code>api_get(**kwargs)</code>","text":"<p>Perform an API call using <code>requests.get()</code> and return the response object. This function adds     logging surrounding the call. </p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Arguments to <code>requests.get()</code> </p> <code>{}</code> <p>Raises:</p> Type Description <code>RequestException</code> <p>If the call cannot return a response.</p> Source code in <code>sandhill/utils/api.py</code> <pre><code>def api_get(**kwargs):\n    \"\"\"\n    Perform an API call using `requests.get()` and return the response object. This function adds \\\n    logging surrounding the call. \\n\n    Args:\n        **kwargs (dict): Arguments to [`requests.get()`](#TODO) \\n\n    Raises:\n        requests.RequestException: If the call cannot return a response. \\n\n    \"\"\"\n    if \"timeout\" not in kwargs:\n        kwargs[\"timeout\"] = 10\n    app.logger.debug(f\"API GET arguments: {kwargs}\")\n    response = requests.get(**kwargs)   # pylint: disable=missing-timeout\n    app.logger.debug(f\"API GET called: {response.url}\")\n    if not response.ok:\n        app.logger.warning(\n            f\"API GET call returned {response.status_code}: {response.text}\"\n        )\n    return response\n</code></pre>"},{"location":"api-reference/#sandhill.utils.api.api_get_multi","title":"<code>api_get_multi(requests_kwargs)</code>","text":"<p>Perform multiple API calls in parellel using futures, returning a list     of responses. </p> <p>Parameters:</p> Name Type Description Default <code>requests_kwargs</code> <code>list of dict</code> <p>Each arguments to [<code>requests.get()</code>] </p> required <p>Returns:</p> Type Description <p>A generator yielding response future objects. Call object.result() to unwrap.</p> Source code in <code>sandhill/utils/api.py</code> <pre><code>def api_get_multi(requests_kwargs):\n    \"\"\"\n    Perform multiple API calls in parellel using futures, returning a list \\\n    of responses. \\n\n    Args:\n        requests_kwargs (list of dict): Each arguments to [`requests.get()`] \\n\n    Returns:\n        A generator yielding response future objects. Call object.result() to unwrap. \\n\n    \"\"\"\n    def request_futures(requests_kwargs):\n        futures = []\n        with FuturesSession() as session:\n            for kwargs in requests_kwargs:\n                if \"timeout\" not in kwargs:\n                    kwargs[\"timeout\"] = 10\n                futures.append(session.get(**kwargs))\n            yield from futures\n\n    return request_futures(requests_kwargs)\n</code></pre>"},{"location":"api-reference/#sandhill.utils.api.establish_url","title":"<code>establish_url(url, fallback)</code>","text":"<p>Set URL to fallback if provided URL is none; also checks the URL validity. </p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A possible URL. </p> required <code>fallback</code> <code>str</code> <p>A secondary URL to fallback to if <code>url</code> is None. </p> required <p>Raises:</p> Type Description <code>HTTPException</code> <p>If URL to be returned is not a valid formatted URL.</p> Source code in <code>sandhill/utils/api.py</code> <pre><code>def establish_url(url, fallback):\n    \"\"\"\n    Set URL to fallback if provided URL is none; also checks the URL validity. \\n\n    Args:\n        url (str): A possible URL. \\n\n        fallback (str): A secondary URL to fallback to if `url` is None. \\n\n    Raises:\n        werkzeurg.exceptions.HTTPException: If URL to be returned is not a valid formatted URL. \\n\n    \"\"\"\n    url = url if url else fallback\n    try:\n        parsed = urlparse(url)\n        if not url or not all([parsed.scheme, parsed.netloc]):\n            raise ValueError\n    except ValueError:\n        app.logger.debug(f\"URL provided is not valid: {url}\")\n        abort(400)\n    return url\n</code></pre>"},{"location":"api-reference/#sandhill.utils.config_loader","title":"<code>sandhill.utils.config_loader</code>","text":"<p>Utilities for loading of loading <code>config/</code> files.</p>"},{"location":"api-reference/#sandhill.utils.config_loader.get_all_routes","title":"<code>get_all_routes(routes_dir='config/routes/')</code>","text":"<p>Finds all routes in JSON files with within given directory and order them     according to the desired load order. </p> <p>Parameters:</p> Name Type Description Default <code>routes_dir</code> <code>str</code> <p>The directory to look for route configs. </p> <code>'config/routes/'</code> <p>Returns:</p> Type Description <code>list</code> <p>All of the route rules found in desired order.</p> Source code in <code>sandhill/utils/config_loader.py</code> <pre><code>def get_all_routes(routes_dir=\"config/routes/\"):\n    '''\n    Finds all routes in JSON files with within given directory and order them \\\n    according to the desired load order. \\n\n    Args:\n        routes_dir (str): The directory to look for route configs. \\n\n    Returns:\n        (list): All of the route rules found in desired order. \\n\n    '''\n    routes = load_routes_from_configs(routes_dir)\n\n    # if no routes are found, add a default one for the home page\n    if not routes:\n        app.logger.warning(\"No routes loaded; will use welcome home page route.\")\n        routes.append(Route(rule=\"/\"))\n\n    # prefer most specifc path (hardcoded path over variable) in left to right manner\n    re_var = re.compile(r'&lt;\\w+:\\w+&gt;')\n    sort_routes = []\n    for route in routes:\n        sort_routes.append((route, re_var.sub(' ', route.rule)))\n    sort_routes = sorted(sort_routes, key=operator.itemgetter(1), reverse=True)\n\n    return [r[0] for r in sort_routes]\n</code></pre>"},{"location":"api-reference/#sandhill.utils.config_loader.load_json_config","title":"<code>load_json_config(file_path)</code>","text":"<p>Load a JSON file. </p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The full path to the JSON file to load </p> required <p>Returns:</p> Type Description <code>dict</code> <p>The contents of the loaded JSON file, or an empty dictionary                 upon error loading or parsing the file.</p> Source code in <code>sandhill/utils/config_loader.py</code> <pre><code>@catch(OSError, \"Unable to read json file at path: {file_path} Error: {exc}\",\n       return_val=collections.OrderedDict())\n@catch(JSONDecodeError, \"Malformed json at path: {file_path} Error: {exc}\",\n       return_val=collections.OrderedDict())\ndef load_json_config(file_path):\n    \"\"\"\n    Load a JSON file. \\n\n    Args:\n        file_path (str): The full path to the JSON file to load \\n\n    Returns:\n        (dict): The contents of the loaded JSON file, or an empty dictionary \\\n                upon error loading or parsing the file. \\n\n    \"\"\"\n    app.logger.debug(f\"Loading json file at {file_path}\")\n    with open(file_path, encoding='utf-8') as json_config_file:\n        return json.load(json_config_file, object_pairs_hook=collections.OrderedDict)\n</code></pre>"},{"location":"api-reference/#sandhill.utils.config_loader.load_json_configs","title":"<code>load_json_configs(path, recurse=False)</code>","text":"<p>Loads all the config files in the provided path. </p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>string</code> <p>The directory path from which to load the config files. </p> required <code>recurse</code> <code>bool</code> <p>If set to True, does a recursive walk into the path. </p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys of each file path and values of their loaded JSON.</p> Source code in <code>sandhill/utils/config_loader.py</code> <pre><code>def load_json_configs(path, recurse=False):\n    \"\"\"\n    Loads all the config files in the provided path. \\n\n    Args:\n        path (string): The directory path from which to load the config files. \\n\n        recurse (bool): If set to True, does a recursive walk into the path. \\n\n    Returns:\n        (dict): Dictionary with keys of each file path and values of their loaded JSON. \\n\n    \"\"\"\n    config_files = {}\n    if not os.path.isdir(path):\n        app.logger.warning(f\"Failed to load json configs; invalid directory: {path}\")\n    for root, _, files in os.walk(path):\n        for config_file in files:\n            if config_file.endswith('.json'):\n                config_file_path = os.path.join(root, config_file)\n                config_files[config_file_path] = load_json_config(config_file_path)\n        if not recurse:\n            break\n\n    return config_files\n</code></pre>"},{"location":"api-reference/#sandhill.utils.config_loader.load_route_config","title":"<code>load_route_config(route_rule, routes_dir='config/routes/')</code>","text":"<p>Return the json data for the provided directory. </p> <p>Parameters:</p> Name Type Description Default <code>route_rule</code> <code>str</code> <p>the route rule to match to in the json configs (the <code>route</code> key) </p> required <code>routes_dir</code> <code>str</code> <p>the path to look for route configs. Default = config/routes/ </p> <code>'config/routes/'</code> <p>Returns:</p> Type Description <code>OrderedDict</code> <p>The loaded json of the matched route config, or empty dict if not found</p> Source code in <code>sandhill/utils/config_loader.py</code> <pre><code>@catch(FileNotFoundError, \"Route dir not found at path {routes_dir} - \" \\\n       \"creating welcome home page route. Error: {exc}\",\n       return_val=collections.OrderedDict({\n           \"route\": [\"/\"],\n           \"template\": \"home.html.j2\"\n       }))\ndef load_route_config(route_rule, routes_dir=\"config/routes/\"):\n    '''\n    Return the json data for the provided directory. \\n\n    Args:\n        route_rule (str): the route rule to match to in the json configs (the `route` key) \\n\n        routes_dir (str): the path to look for route configs. Default = config/routes/ \\n\n    Returns:\n        (OrderedDict): The loaded json of the matched route config, or empty dict if not found \\n\n    '''\n    route_path = os.path.join(app.instance_path, routes_dir)\n    data = collections.OrderedDict()\n    conf_files = [\n        os.path.join(route_path, j) for j in os.listdir(route_path) if j.endswith(\".json\")\n    ]\n    for conf_file in conf_files:\n        check_data = load_json_config(conf_file)\n        if route_rule in tolistfromkeys(check_data, \"route\", \"routes\"):\n            data = check_data\n            break\n    return data\n</code></pre>"},{"location":"api-reference/#sandhill.utils.config_loader.load_routes_from_configs","title":"<code>load_routes_from_configs(routes_dir='config/routes/')</code>","text":"<p>Given a path relative to the <code>instance/</code> dir, load all JSON files within     and extract the \"route\" keys. </p> <p>Parameters:</p> Name Type Description Default <code>routes_dir</code> <code>string</code> <p>The relative path to the JSON files </p> <code>'config/routes/'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of routes from the configs</p> Source code in <code>sandhill/utils/config_loader.py</code> <pre><code>@catch(FileNotFoundError, \"Route dir not found at path {routes_dir} Error: {exc}\", return_val=[])\ndef load_routes_from_configs(routes_dir=\"config/routes/\"):\n    '''\n    Given a path relative to the `instance/` dir, load all JSON files within \\\n    and extract the \"route\" keys. \\n\n    Args:\n        routes_dir (string): The relative path to the JSON files \\n\n    Returns:\n        (list): A list of routes from the configs \\n\n    '''\n    route_path = os.path.join(app.instance_path, routes_dir)\n    routes = []\n    conf_files = [\n        os.path.join(route_path, j) for j in os.listdir(route_path) if j.endswith(\".json\")\n    ]\n    for conf_file in conf_files:\n        data = load_json_config(conf_file)\n        r_rules = tolist(*[data.get(key) for key in (\"route\", \"routes\") if key in data])\n        methods = tolist(*[data.get(key) for key in (\"method\", \"methods\") if key in data])\n        for rule in r_rules:\n            routes.append(Route(\n                rule=rule,\n                methods=methods,\n            ))\n    return routes\n</code></pre>"},{"location":"api-reference/#sandhill.utils.context","title":"<code>sandhill.utils.context</code>","text":"<p>Context related functionality</p>"},{"location":"api-reference/#sandhill.utils.context.app_context","title":"<code>app_context()</code>","text":"<p>Create a flask app context if not already present.</p> <pre><code># Example use\nwith context.app_context():\n    ...\n</code></pre> <p>Returns:</p> Type Description <p>A context manager class instance.</p> Source code in <code>sandhill/utils/context.py</code> <pre><code>def app_context():\n    \"\"\"\n    Create a flask app context if not already present.\\n\n    ```\n    # Example use\n    with context.app_context():\n        ...\n    ``` \\n\n    Returns:\n        A context manager class instance. \\n\n    \"\"\"\n    class NullContext: # pylint: disable=all\n        def __enter__(self): return None\n        def __exit__(self, exc_type, exc_value, traceback): return None\n\n    return app.app_context() if not has_app_context() else NullContext()\n</code></pre>"},{"location":"api-reference/#sandhill.utils.context.context_processors","title":"<code>context_processors()</code>","text":"<p>The list of  Sandhill context processor functions. </p> <p>Returns:</p> Type Description <code>dict</code> <p>Context processors mapped as: name =&gt; function</p> Source code in <code>sandhill/utils/context.py</code> <pre><code>@app.context_processor\ndef context_processors():\n    \"\"\"\n    The list of  Sandhill context processor functions. \\n\n    Returns:\n        (dict): Context processors mapped as: name =&gt; function \\n\n    \"\"\"\n    # TODO move function definitions to sandhill/context/ and import them for use below\n\n    def strftime(fmt: str = None, day: str = None) -&gt; str:\n        \"\"\"\n        Wrapper around datetime.strftime with default yyyy-mm-dd format \\n\n        args:\n            fmt (str): The format for the date to return \\n\n            day (str): A date in yyyy-mm-dd format to format, or today if not passed \\n\n        returns:\n            (str): The formatted date \\n\n        \"\"\"\n        fmt = \"%Y-%m-%d\" if not fmt else fmt\n        day = datetime.now() if not day else datetime.strptime(day, \"%Y-%m-%d\")\n        return day.strftime(fmt)\n\n    def context_sandbug(value: Any, comment: str = None):\n        \"\"\"\n        Sandbug as a context processor, because we can. Will output the given \\\n        value into the logs. For debugging. \\n\n        Args:\n            value (Any): The value to debug. \\n\n            comment (str): Additional comment to add to log output. \\n\n        Returns:\n            (None): Sandbug does not return a value. \\n\n        \"\"\"\n        sandbug(value, comment) # pylint: disable=undefined-variable\n\n    def urlcomponents():\n        \"\"\"\n        Creates a deepcopy of the url components part of the request object. \\n\n        Returns:\n            (dict): The copied data. \\n\n        \"\"\"\n        try:\n            return {\n                \"path\": str(request.path),\n                \"full_path\": str(request.full_path),\n                \"base_url\": str(request.base_url),\n                \"url\": str(request.url),\n                \"url_root\": str(request.url_root),\n                \"query_args\": deepcopy(request.query_args),\n                \"host\": str(request.host)\n            }\n        except (UnicodeDecodeError, TypeError):\n            abort(400)\n\n    def find_mismatches(dict1: dict, dict2: dict) -&gt; dict:\n        \"\"\"\n        Return detailed info about how and where the two supplied dicts don't match. \\n\n        Args:\n            dict1 (dict): A dictionary to compare. \\n\n            dict2 (dict): A dictionary to compare. \\n\n        Returns:\n            (dict) A dictionary highlighting what is different between the two inputs. \\n\n        \"\"\"\n        return dict(DeepDiff(dict1, dict2, ignore_order=True))\n\n    @pass_context\n    def get_var(context, var: str):\n        \"\"\"\n        Returns the given variable in the current application context \\n\n        Args:\n            var (str): The name of the variable to get from the context \\n\n        Returns:\n            (any): The value of the provided variable in the current context \\n\n        \"\"\"\n        ctx = dict(context)\n        return ctx[var] if var in ctx else None\n\n    # Mapping of context function names to actual functions\n    return {\n        'debug': app.debug,\n        'strftime': strftime,\n        'sandbug': context_sandbug,\n        'urlcomponents': urlcomponents,\n        'find_mismatches': find_mismatches,\n        'get_var': get_var\n    }\n</code></pre>"},{"location":"api-reference/#sandhill.utils.context.list_custom_context_processors","title":"<code>list_custom_context_processors()</code>","text":"<p>Get the full list of the available custom context processors. </p> <p>Returns:</p> Type Description <code>list</code> <p>A list of strings of the context processor names.</p> Source code in <code>sandhill/utils/context.py</code> <pre><code>def list_custom_context_processors():\n    \"\"\"\n    Get the full list of the available custom context processors. \\n\n    Returns:\n        (list): A list of strings of the context processor names. \\n\n    \"\"\"\n    custom = []\n    for entries in app.template_context_processors[None]:\n        ctx_procs = entries()\n        for key in ctx_procs:\n            if key not in ['g', 'request', 'session']:\n                custom.append(key)\n    return custom\n</code></pre>"},{"location":"api-reference/#sandhill.utils.error_handling","title":"<code>sandhill.utils.error_handling</code>","text":"<p>Methods to help handle errors</p>"},{"location":"api-reference/#sandhill.utils.error_handling.catch","title":"<code>catch(exc_class, exc_msg=None, **kwargs)</code>","text":"<p>Decorator to catch general exceptions and handle in a standarized manor. </p> <p>Parameters:</p> Name Type Description Default <code>exc_class</code> <code>Exception</code> <p>Type of exception to catch </p> required <code>exc_msg</code> <code>String) (optional</code> <p>Message to log; the             parameter <code>{exc}</code> is available in the string template.</p> <p>Ex: <code>f\"Error: {exc}\"</code> </p> <code>None</code> <code>**kwargs</code> <p>Optional arguments:</p> <p>return_val (Any): Value to return after the exception has been handled</p> <p>return_arg (str): Function kwarg to be returned after the exception has been handled</p> <p>abort (int): Status code to abort with </p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Only if return_val or return_arg is provided in kwargs. </p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If no return_val or return_arg is provided in kwargs. </p> <p>Examples: <pre><code>@catch(KeyError, \"Some error message\", return_val=None)\ndef myfunc():\n    ...\n\n@catch((KeyError, IndexError), \"Some error message\", return_arg='myval')\ndef myfunc(myval):\n    ...\n</code></pre></p> Source code in <code>sandhill/utils/error_handling.py</code> <pre><code>def catch(exc_class, exc_msg=None, **kwargs):\n    \"\"\"\n    Decorator to catch general exceptions and handle in a standarized manor. \\n\n    Args:\n        exc_class (Exception): Type of exception to catch \\n\n        exc_msg (String) (optional): Message to log; the \\\n            parameter `{exc}` is available in the string template.\\n\n            Ex: `f\"Error: {exc}\"` \\n\n        **kwargs: Optional arguments:\\n\n            return_val (Any): Value to return after the exception has been handled\\n\n            return_arg (str): Function kwarg to be returned after the exception has been handled\\n\n            abort (int): Status code to abort with \\n\n    Returns:\n        (Any): Only if return_val or return_arg is provided in kwargs. \\n\n    Raises:\n        (HTTPException): If no return_val or return_arg is provided in kwargs. \\n\n    Examples:\n    ```python\n    @catch(KeyError, \"Some error message\", return_val=None)\n    def myfunc():\n        ...\n\n    @catch((KeyError, IndexError), \"Some error message\", return_arg='myval')\n    def myfunc(myval):\n        ...\n    ``` \\n\n    \"\"\"\n    def inner(func):\n        @wraps(func)\n        def wrapper(*args, **func_kwargs):\n            try:\n                rval = func(*args, **func_kwargs)\n            except exc_class as exc:\n                # Re-map the function arguments to their variable name\n                # for use in formatted error message string\n                args_dict = {**_get_func_params(func, args), **func_kwargs}\n                args_dict['exc'] = exc\n\n                # Handling of the exception\n                if exc_msg:\n                    sandhill.app.logger.warning(f\"{request.url if request else ''} raised: \" + \\\n                        exc_msg.format(**args_dict))\n\n                # Get the return_arg value if required and present in the function's arguments\n                return_arg = None\n                if 'return_arg' in kwargs:\n                    if kwargs.get('return_arg') and kwargs.get('return_arg') in args_dict:\n                        return_arg = args_dict[kwargs.get('return_arg')]\n\n                # Abort if specified\n                if 'abort' in kwargs:\n                    abort(kwargs.get('abort'))\n\n                # If no return_val specified, we'll re-raise the error\n                if 'return_val' not in kwargs and 'return_arg' not in kwargs:\n                    raise exc\n                rval = return_arg if return_arg else kwargs.get('return_val')\n            return rval\n        return wrapper\n    return inner\n</code></pre>"},{"location":"api-reference/#sandhill.utils.error_handling.dp_abort","title":"<code>dp_abort(http_code)</code>","text":"<p>Data processor abort. Will abort with the given status code if     the data processor has an <code>on_fail</code> key set and the value is <code>0</code>. </p> <p>If the value is non-<code>0</code>, the 'on_fail' code will override     the passed code. </p> <p>Parameters:</p> Name Type Description Default <code>http_code</code> <code>int</code> <p>A valid HTTP status code </p> required <p>Raises:</p> Type Description <code>HTTPException</code> <p>Can raises exception if data processor's <code>on_fail</code> is             defined in parent context</p> Source code in <code>sandhill/utils/error_handling.py</code> <pre><code>def dp_abort(http_code):\n    \"\"\"\n    Data processor abort. Will abort with the given status code if \\\n    the data processor has an `on_fail` key set and the value is `0`. \\n\n    If the value is non-`0`, the 'on_fail' code will override \\\n    the passed code. \\n\n    Args:\n        http_code (int): A valid HTTP status code \\n\n    Raises:\n        (HTTPException): Can raises exception if data processor's `on_fail` is \\\n            defined in parent context \\n\n    \"\"\"\n    parent_locals = inspect.currentframe().f_back.f_locals\n    data = parent_locals['data'] if 'data' in parent_locals else {}\n    if 'on_fail' in data:\n        abort(http_code if data['on_fail'] == 0 else data['on_fail'])\n</code></pre>"},{"location":"api-reference/#sandhill.utils.generic","title":"<code>sandhill.utils.generic</code>","text":"<p>Generic functions that could be used in most any context.</p>"},{"location":"api-reference/#sandhill.utils.generic.getconfig","title":"<code>getconfig(name, default=None)</code>","text":"<p>Get the value of the given config name. It will first     check in the app.config for the variable name, if not found it     will then look look in the os.environ, if still not found     it will use the default param </p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the config variable to look for </p> required <code>default</code> <code>str | None</code> <p>The defaut value if not found elsewhere </p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Value of the config variable, default value otherwise</p> Source code in <code>sandhill/utils/generic.py</code> <pre><code>def getconfig(name, default=None):\n    '''\n    Get the value of the given config name. It will first \\\n    check in the app.config for the variable name, if not found it \\\n    will then look look in the os.environ, if still not found \\\n    it will use the default param \\n\n    Args:\n        name (str): Name of the config variable to look for \\n\n        default (str|None): The defaut value if not found elsewhere \\n\n    Returns:\n        (str): Value of the config variable, default value otherwise \\n\n    '''\n    value = default\n    # XXX os.environ is loaded via bootstrap/__init__.py into app.config\n    #     between loading sandhill.default_settings.cfg and instance/sandhill.cfg\n    if app.config.get(name) is not None:\n        value = app.config[name]\n    return value\n</code></pre>"},{"location":"api-reference/#sandhill.utils.generic.getdescendant","title":"<code>getdescendant(obj, list_keys, extract=False, put=None)</code>","text":"<p>Gets key values from the dictionary/list if they exist; </p> <p>will check recursively through the <code>obj</code>. </p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>dict | list</code> <p>A dict/list to check, possibly containing nested dicts/lists. </p> required <code>list_keys</code> <code>list | str</code> <p>List of descendants to follow (or . delimited string) </p> required <code>extract</code> <code>bool</code> <p>If set to true, will remove the last matching value from the <code>obj</code>. </p> <code>False</code> <code>put</code> <code>Any</code> <p>Replace the found value with this new value in the <code>obj</code>,                    or append if the found value at a list key of <code>\"[]\"</code> </p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The last matching value from list_keys, or None if no match </p> <p>Raises:</p> Type Description <code>IndexError</code> <p>When attempting to put a list index that is invalid. </p> <p>Examples: <pre><code># Get \"key1\" of mydict, then index 2 of that result, then \"key3\" of that result\nv = getdescendant(mydict, \"key1.2.key3\")\n# Same as above, only also remove the found item from mydict\nv = getdescendant(mydict, \"key1.2.key3\", extract=True)\n# Replace value with new value\nv = getdescendant(mydict, \"key1.2.key3\", put=\"Replacement value!\")\n# Append to a list\nv = getdescendant(mydict, \"key1.2.[]\", put=\"Append this value.\")\n</code></pre></p> Source code in <code>sandhill/utils/generic.py</code> <pre><code>@catch(ValueError, \"Could not find {list_keys} in: {obj}\", return_val=None)\ndef getdescendant(obj, list_keys, extract=False, put=None):\n    '''\n    Gets key values from the dictionary/list if they exist; \\n\n    will check recursively through the `obj`. \\n\n    Args:\n        obj (dict|list): A dict/list to check, possibly containing nested dicts/lists. \\n\n        list_keys (list|str): List of descendants to follow (or . delimited string) \\n\n        extract (bool): If set to true, will remove the last matching value from the `obj`. \\n\n        put (Any): Replace the found value with this new value in the `obj`, \\\n                   or append if the found value at a list key of `\"[]\"` \\n\n    Returns:\n        (Any): The last matching value from list_keys, or None if no match \\n\n    Raises:\n        IndexError: When attempting to put a list index that is invalid. \\n\n    Examples:\n    ```python\n    # Get \"key1\" of mydict, then index 2 of that result, then \"key3\" of that result\n    v = getdescendant(mydict, \"key1.2.key3\")\n    # Same as above, only also remove the found item from mydict\n    v = getdescendant(mydict, \"key1.2.key3\", extract=True)\n    # Replace value with new value\n    v = getdescendant(mydict, \"key1.2.key3\", put=\"Replacement value!\")\n    # Append to a list\n    v = getdescendant(mydict, \"key1.2.[]\", put=\"Append this value.\")\n    ``` \\n\n    '''\n    list_keys = list_keys.split('.') if isinstance(list_keys, str) else list_keys\n    for idx, key in enumerate(list_keys):\n        pobj = obj\n        if isinstance(obj, Mapping) and key in obj:\n            obj = obj[key]\n        elif isinstance(obj, list) and str(key).isdigit() and int(key) &lt; len(obj):\n            key = int(key)\n            obj = obj[key]\n        else:\n            obj = None\n        #  This is the last key in the loop\n        if (idx + 1) == len(list_keys):\n            if extract and obj is not None:\n                del pobj[key]\n            if put is not None and pobj is not None:\n                if isinstance(pobj, Mapping):\n                    pobj[key] = put\n                if isinstance(pobj, list):\n                    if key == \"[]\":\n                        pobj.append(put)\n                    elif isinstance(key, int) and key &lt; len(pobj):\n                        pobj[key] = put\n                    else:\n                        raise IndexError(f\"Index of {key} is invalid for list: {pobj}\")\n    return obj if list_keys else None\n</code></pre>"},{"location":"api-reference/#sandhill.utils.generic.getindex","title":"<code>getindex(fromlist: list, idx: str | int, default_idx: int = 0, default_val=None)</code>","text":"<p>Get the value from a list for a given index. If the given index     is not valid, a default index is used instead. </p> <p>Parameters:</p> Name Type Description Default <code>fromlist</code> <code>list</code> <p>List in which to find indexes </p> required <code>idx</code> <code>str | int</code> <p>The index to find; str values allowed and cast to int </p> required <code>default_idx</code> <code>int</code> <p>The default index to use if idx is not valid </p> <code>0</code> <code>default_val</code> <code>Any</code> <p>The value to return if the idx and default_idx are             both invalid </p> <code>None</code> <p>Returns:</p> Type Description <p>(Any) A value from the list, or the default_val</p> Source code in <code>sandhill/utils/generic.py</code> <pre><code>def getindex(fromlist: list, idx: str|int, default_idx: int=0, default_val=None):\n    \"\"\"\n    Get the value from a list for a given index. If the given index \\\n    is not valid, a default index is used instead. \\n\n    Args:\n        fromlist (list): List in which to find indexes \\n\n        idx (str|int): The index to find; str values allowed and cast to int \\n\n        default_idx (int): The default index to use if idx is not valid \\n\n        default_val (Any): The value to return if the idx and default_idx are \\\n            both invalid \\n\n    Returns:\n        (Any) A value from the list, or the default_val \\n\n    \"\"\"\n    try:\n        idx = int(idx)\n    except (ValueError, TypeError):\n        idx = default_idx\n    try:\n        return fromlist[idx]\n    except IndexError:\n        return default_val\n</code></pre>"},{"location":"api-reference/#sandhill.utils.generic.getmodulepath","title":"<code>getmodulepath(path)</code>","text":"<p>Get the Python module path for a directory or file in Sandhill </p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>A file or dir path in Sandhill </p> required <p>Returns:</p> Type Description <code>str</code> <p>module (e.g. 'instance' or 'sandhill.filters.filters')</p> Source code in <code>sandhill/utils/generic.py</code> <pre><code>def getmodulepath(path):\n    \"\"\"\n    Get the Python module path for a directory or file in Sandhill \\n\n    Args:\n        path (str): A file or dir path in Sandhill \\n\n    Returns:\n        (str): module (e.g. 'instance' or 'sandhill.filters.filters') \\n\n    \"\"\"\n    install_path = os.path.dirname(app.root_path)\n    subpath = os.path.relpath(path, start=install_path)\n    return subpath.removesuffix('.py').replace('/', '.').strip('.')\n</code></pre>"},{"location":"api-reference/#sandhill.utils.generic.ifnone","title":"<code>ifnone(*args)</code>","text":"<p>Returns the default value if the key is not in the dictionary or if     a non-dictionary is provided it will return the default if it is not set. </p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>With 3 args:</p> <pre><code>var (dict): The dictionary to check\n\nkey (str): The key of the dictionary\n\ndefault_value (Any): Return val if key is not in var\n</code></pre> <p>With 2 args:</p> <pre><code>var (Any): The variable to check\n\ndefault_value (Any): Return val if the variable is None\n</code></pre> <code>()</code> <p>Returns:</p> Type Description <p>(Any) The default_value if the value is None or the key is not in the dict. </p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If invalid number of arguments passed.</p> Source code in <code>sandhill/utils/generic.py</code> <pre><code>def ifnone(*args):\n    '''\n    Returns the default value if the key is not in the dictionary or if \\\n    a non-dictionary is provided it will return the default if it is not set. \\n\n    Args:\n        *args (Any):\n            With 3 args:\\n\n                var (dict): The dictionary to check\\n\n                key (str): The key of the dictionary\\n\n                default_value (Any): Return val if key is not in var\\n\n            With 2 args:\\n\n                var (Any): The variable to check\\n\n                default_value (Any): Return val if the variable is None\\n\n    Returns:\n        (Any) The default_value if the value is None or the key is not in the dict. \\n\n    Raises:\n        (TypeError): If invalid number of arguments passed. \\n\n    '''\n    var = args[0] if args else None\n    if len(args) not in [2, 3]:\n        raise TypeError(\n            f\"ifnone() missing required positional argument (2 or 3) {len(args)} received.\"\n        )\n    if len(args) == 3:\n        key = args[1]\n        default_val = args[2]\n        return var[key] if isinstance(var, dict) and key in var else default_val # pylint: disable=unsupported-membership-test,unsubscriptable-object\n    # len(args) == 2\n    default_value = args[1]\n    return var if var is not None else default_value\n</code></pre>"},{"location":"api-reference/#sandhill.utils.generic.overlay_dicts_matching_key","title":"<code>overlay_dicts_matching_key(target: list[dict], overlays: list[dict], key: Hashable)</code>","text":"<p>Given the target, find and replace matching dicts, for all matching dicts     in the list of overlays, using the value for the provided key to compare them. </p> <p>For each overlay dict, overlay the values on top of any matching original     dict from the target. </p> <p>If multiple overlays match an original target dict, both overlays will use     the original dict as a base for the overlay. </p> <p>If no matching dict was found in the original target list, the overlay will be     appended to the target as is. </p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>list</code> <p>The list of dicts to search and update. </p> required <code>overlays</code> <code>list</code> <p>The list of dict match and overlay. </p> required <code>key</code> <code>Hashable</code> <p>The key (both dicts) for the comparison value.</p> required Source code in <code>sandhill/utils/generic.py</code> <pre><code>def overlay_dicts_matching_key(target: list[dict], overlays: list[dict], key: Hashable):\n    \"\"\"\n    Given the target, find and replace matching dicts, for all matching dicts \\\n    in the list of overlays, using the value for the provided key to compare them. \\n\n    For each overlay dict, overlay the values on top of any matching original \\\n    dict from the target. \\n\n    If multiple overlays match an original target dict, both overlays will use \\\n    the original dict as a base for the overlay. \\n\n    If no matching dict was found in the original target list, the overlay will be \\\n    appended to the target as is. \\n\n    Args:\n        target (list): The list of dicts to search and update. \\n\n        overlays (list): The list of dict match and overlay. \\n\n        key (Hashable): The key (both dicts) for the comparison value. \\n\n    \"\"\"\n    base_ref = {}\n    # Extract all base/default dictionaries from target\n    for overlay in overlays:\n        if (oval := overlay.get(key)):\n            if [base_dict := tdict for tdict in target if tdict.get(key) == oval]:\n                target.remove(base_dict)\n                base_ref[oval] = base_dict\n\n    # For each overlay, copy matching base and update with overlay before appending\n    for overlay in overlays:\n        if (base_dict := base_ref.get(overlay.get(key))):\n            overlay = {**base_dict, **overlay}\n        target.append(overlay)\n</code></pre>"},{"location":"api-reference/#sandhill.utils.generic.pop_dict_matching_key","title":"<code>pop_dict_matching_key(haystack: list[dict], match: dict, key: Hashable) -&gt; list[dict]</code>","text":"<p>Search the haystack for all dicts that have the same     value as the passed match dict for the given key. </p> <p>Matched dicts are removed from the haystack and     returned as a list. </p> <p>Parameters:</p> Name Type Description Default <code>haystack</code> <code>list</code> <p>A list of dicts to search through. </p> required <code>match</code> <code>dict</code> <p>The dict to match against. </p> required <code>key</code> <code>Hashable</code> <p>The key (both dicts) for the comparison value. </p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of matching dicts removed from the haystack.</p> Source code in <code>sandhill/utils/generic.py</code> <pre><code>def pop_dict_matching_key(haystack: list[dict], match: dict, key: Hashable) -&gt; list[dict]:\n    \"\"\"\n    Search the haystack for all dicts that have the same \\\n    value as the passed match dict for the given key. \\n\n    Matched dicts are removed from the haystack and \\\n    returned as a list. \\n\n    Args:\n        haystack (list): A list of dicts to search through. \\n\n        match (dict): The dict to match against. \\n\n        key (Hashable): The key (both dicts) for the comparison value. \\n\n    Returns:\n        (list): A list of matching dicts removed from the haystack. \\n\n    \"\"\"\n    matched = []\n    if (needle_val := match.get(key)):\n        for hay in list(haystack):\n            if hay.get(key) == needle_val:\n                matched.append(hay)\n                haystack.remove(hay)\n    return matched\n</code></pre>"},{"location":"api-reference/#sandhill.utils.generic.recursive_merge","title":"<code>recursive_merge(dict1: dict, dict2: dict, sanity: int = 100) -&gt; dict</code>","text":"<p>Given 2 dictionaries, merge them together, overriding dict1     values by dict2 if existing in both.</p> <p>Parameters:</p> Name Type Description Default <code>dict1</code> <code>dict</code> <p>Base dictionary, keys will be overridden if the keys are in both. </p> required <code>dict2</code> <code>dict</code> <p>Prioritized dictionary, keys will be kept if the keys are in both. </p> required <code>sanity</code> <code>int</code> <p>The depth to reach before raising an error. </p> <code>100</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dict1 and dict2 merged</p> <p>Raises:</p> Type Description <code>RecursionError</code> <p>if dictionary depth reaches sanity</p> <code>TypeError</code> <p>dict1 and dict2 needs to be dictionaries, sanity needs to be an integer</p> Source code in <code>sandhill/utils/generic.py</code> <pre><code>def recursive_merge(dict1: dict, dict2: dict, sanity: int = 100) -&gt; dict:\n    \"\"\"\n    Given 2 dictionaries, merge them together, overriding dict1 \\\n    values by dict2 if existing in both.\\n\n\n    Args:\n        dict1 (dict): Base dictionary, keys will be overridden if the keys are in both. \\n\n        dict2 (dict): Prioritized dictionary, keys will be kept if the keys are in both. \\n\n        sanity (int): The depth to reach before raising an error. \\n\n\n    Returns:\n        dict: dict1 and dict2 merged\\n\n\n    Raises:\n        RecursionError: if dictionary depth reaches sanity\\n\n        TypeError: dict1 and dict2 needs to be dictionaries, sanity needs to be an integer\\n\n    \"\"\"\n    if not (isinstance(dict1, dict) and isinstance(dict2, dict) and isinstance(sanity, int)):\n        raise TypeError(('The function only accepts dictionaries'\n                    ' as dict1 and dict2 and integer as sanity'))\n    merged = dict1.copy()\n    sanity -= 1\n    if sanity &lt; 0:\n        raise RecursionError('Reached depth limit of recursion, aborting')\n    for key, value in dict2.items():\n        if key in merged and isinstance(merged[key], dict) and isinstance(value, dict):\n            merged[key] = recursive_merge(merged[key], value, sanity)\n        elif value is None and key in merged:\n            del merged[key]\n        else:\n            merged[key] = value\n    return merged\n</code></pre>"},{"location":"api-reference/#sandhill.utils.generic.tolist","title":"<code>tolist(*args)</code>","text":"<p>Combine arguments, appending them to a list; args may be scalars or lists. If args is     a list, then the values of the list are appended (not the list itself). </p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Items to combine. </p> <code>()</code> <p>Returns:</p> Type Description <code>list</code> <p>The combined list.</p> Source code in <code>sandhill/utils/generic.py</code> <pre><code>def tolist(*args):\n    \"\"\"\n    Combine arguments, appending them to a list; args may be scalars or lists. If args is \\\n    a list, then the values of the list are appended (not the list itself). \\n\n    Args:\n        *args (Any): Items to combine. \\n\n    Returns:\n        (list): The combined list. \\n\n    \"\"\"\n    combined = []\n    for i in args:\n        if isinstance(i, list):\n            combined += i\n        else:\n            combined.append(i)\n    return combined\n</code></pre>"},{"location":"api-reference/#sandhill.utils.generic.tolistfromkeys","title":"<code>tolistfromkeys(fromdict, *args)</code>","text":"<p>From a given dict, find all keys and return them within a list. </p> <p>If found keys are already a list, then extends the return list with the matched value     instead of appending a list within a list. </p> <p>Parameters:</p> Name Type Description Default <code>fromdict</code> <code>dict</code> <p>Dictionary to search within. </p> required <code>*args</code> <code>str | int</code> <p>Keys to find. </p> <code>()</code> <p>Returns:</p> Type Description <code>list</code> <p>The list with found key values.</p> Source code in <code>sandhill/utils/generic.py</code> <pre><code>def tolistfromkeys(fromdict, *args):\n    \"\"\"\n    From a given dict, find all keys and return them within a list. \\n\n    If found keys are already a list, then extends the return list with the matched value \\\n    instead of appending a list within a list. \\n\n    Args:\n        fromdict (dict): Dictionary to search within. \\n\n        *args (str|int): Keys to find. \\n\n    Returns:\n        (list): The list with found key values. \\n\n    \"\"\"\n    values = []\n    for arg in args:\n        if arg in fromdict:\n            value = fromdict[arg]\n            values.extend(value if isinstance(value, list) else [value])\n    return values\n</code></pre>"},{"location":"api-reference/#sandhill.utils.generic.touniquelist","title":"<code>touniquelist(*args)</code>","text":"<p>Combine arguments while excluding duplicate values. Same functionality as <code>tolist()</code>     only with duplicate values being removed. </p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Items to combine. </p> <code>()</code> <p>Returns:</p> Type Description <code>list</code> <p>The combined list with duplicates removed.</p> Source code in <code>sandhill/utils/generic.py</code> <pre><code>def touniquelist(*args):\n    \"\"\"\n    Combine arguments while excluding duplicate values. Same functionality as `tolist()` \\\n    only with duplicate values being removed. \\n\n    Args:\n        *args (Any): Items to combine. \\n\n    Returns:\n        (list): The combined list with duplicates removed. \\n\n    \"\"\"\n    unique_list = []\n    _ = [unique_list.append(i) for i in tolist(*args) if i not in unique_list]\n    return unique_list\n</code></pre>"},{"location":"api-reference/#utilshtmlhtmltagfilter","title":"<code>utils.html.HTMLTagFilter</code>","text":"<p>Class used to filter through HTML and remove all tags except for those set as allowed. Used by the <code>filtertags()</code> template filter.</p>"},{"location":"api-reference/#sandhill.utils.jsonpath","title":"<code>sandhill.utils.jsonpath</code>","text":"<p>Wrapper functions for JSONPath queries.</p>"},{"location":"api-reference/#sandhill.utils.jsonpath.json_from_url","title":"<code>json_from_url(url, timeout=None)</code>","text":"<p>Try to load URL and retrieve JSON data. </p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to retrieve </p> required <code>timeout</code> <p>An integer timeout in seconds; defaults to 10 if not set </p> <code>None</code> <p>Returns:</p> Type Description <code>dict | list | None</code> <p>The parsed JSON, or None on failure</p> Source code in <code>sandhill/utils/jsonpath.py</code> <pre><code>@catch(RequestException, \"JSON API call failed: {url} Exc: {exc}\", return_val=None)\n@catch(RequestsConnectionError, \"Invalid host for API call: {url} Exc: {exc}\", return_val=None)\ndef json_from_url(url, timeout=None):\n    '''\n    Try to load URL and retrieve JSON data. \\n\n    Args:\n        url (str): The URL to retrieve \\n\n        timeout: An integer timeout in seconds; defaults to 10 if not set \\n\n    Returns:\n        (dict|list|None): The parsed JSON, or None on failure \\n\n    '''\n    if timeout is None:\n        timeout = 10\n    if not checkers.is_url(url):\n        app.logger.warning(f\"Cannot load JSON from invalid URL: {url}\")\n    else:\n        response = requests.get(url, timeout=timeout)\n        if response:\n            return response.json()\n        app.logger.warning(f\"Failed to retrieve valid response (or timed out): {url}\")\n    return None\n</code></pre>"},{"location":"api-reference/#sandhill.utils.jsonpath.find","title":"<code>find(data, path=None, deepcopy=True)</code>","text":"<p>Get the values for a given JSONPath. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>The JSON data </p> required <code>path</code> <code>str</code> <p>The JSONPath to find </p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of matches, empty if none found</p> Source code in <code>sandhill/utils/jsonpath.py</code> <pre><code>def find(data, path=None, deepcopy=True):\n    '''\n    Get the values for a given JSONPath. \\n\n    Args:\n        data (dict|list): The JSON data \\n\n        path (str): The JSONPath to find \\n\n    Returns:\n        (list): A list of matches, empty if none found \\n\n    '''\n    if deepcopy:\n        data = copy.deepcopy(data)\n    if path is None:\n        return data\n    pattern = parse(path)\n    matches = pattern.find(data)\n    return [match.value for match in matches]\n</code></pre>"},{"location":"api-reference/#sandhill.utils.jsonpath.put","title":"<code>put(data, path, value, deepcopy=True)</code>","text":"<p>Set a value at the given JSONPath location. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>The JSON data </p> required <code>path</code> <code>str</code> <p>The JSONPath to find </p> <p>Last element in path will be removed, which must be             a specific Field or Index only </p> required <code>value</code> <code>any</code> <p>The value to set</p> required <p>Returns:</p> Type Description <code>dict | list</code> <p>The modified JSON data</p> Source code in <code>sandhill/utils/jsonpath.py</code> <pre><code>def put(data, path, value, deepcopy=True):\n    '''\n    Set a value at the given JSONPath location. \\n\n    Args:\n        data (dict|list): The JSON data \\n\n        path (str): The JSONPath to find \\n\n            Last element in path will be removed, which must be \\\n            a specific Field or Index only \\n\n        value (any): The value to set\\n\n    Returns:\n        (dict|list): The modified JSON data \\n\n    '''\n    if deepcopy:\n        data = copy.deepcopy(data)\n    pattern = parse(path)\n    if not isinstance(pattern.right, Fields) and not isinstance(pattern.right, Index):\n        raise ValueError(\"jsonpath.put can only set specific Fields or Indexes\")\n\n    matches = pattern.left.find(data)\n    for match in matches:\n        new_value = match.value\n        idxs = [pattern.right.index] if isinstance(pattern.right, Index) \\\n            else pattern.right.reified_fields(match.context)\n        for idx in idxs:\n            new_value[idx] = value\n        parse(str(match.full_path)).update(data, new_value)\n\n    return data\n</code></pre>"},{"location":"api-reference/#sandhill.utils.jsonpath.append","title":"<code>append(data, path, value, deepcopy=True)</code>","text":"<p>Append a value to the given JSONPath location. Location must be a list. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>The JSON data </p> required <code>path</code> <code>str</code> <p>The JSONPath to a list(s) </p> required <code>value</code> <code>any</code> <p>The value to append </p> required <p>Returns:</p> Type Description <code>dict | list</code> <p>The modified JSON data</p> Source code in <code>sandhill/utils/jsonpath.py</code> <pre><code>def append(data, path, value, deepcopy=True):\n    '''\n    Append a value to the given JSONPath location. Location must be a list. \\n\n    Args:\n        data (dict|list): The JSON data \\n\n        path (str): The JSONPath to a list(s) \\n\n        value (any): The value to append \\n\n    Returns:\n        (dict|list): The modified JSON data \\n\n    '''\n    if deepcopy:\n        data = copy.deepcopy(data)\n    pattern = parse(path)\n    matches = pattern.find(data)\n    for match in matches:\n        section = match.value\n        if not isinstance(section, list):\n            raise ValueError(\"jsonpath.append can only do so to a list. \" \\\n                             f\"Path '{path}' found type {type(section)}\")\n        section.append(value)\n        parse(str(match.full_path)).update(data, section)\n    return data\n</code></pre>"},{"location":"api-reference/#sandhill.utils.jsonpath.delete","title":"<code>delete(data, path, deepcopy=True)</code>","text":"<p>Delete item(s) from JSON data. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>The JSON data </p> required <code>path</code> <code>str</code> <p>The JSONPath to the object(s) to delete </p> <p>Last element in path will be removed, which must be             a specific Field or Index only </p> required <p>Returns:</p> Type Description <code>dict | list</code> <p>The modified JSON data</p> Source code in <code>sandhill/utils/jsonpath.py</code> <pre><code>def delete(data, path, deepcopy=True):\n    '''\n    Delete item(s) from JSON data. \\n\n    Args:\n        data (dict|list): The JSON data \\n\n        path (str): The JSONPath to the object(s) to delete \\n\n            Last element in path will be removed, which must be \\\n            a specific Field or Index only \\n\n    Returns:\n        (dict|list): The modified JSON data \\n\n    '''\n    if deepcopy:\n        data = copy.deepcopy(data)\n    pattern = parse(path)\n    if not isinstance(pattern.right, Fields) and not isinstance(pattern.right, Index):\n        raise ValueError(\"jsonpath.put can only set specific Fields or Indexes\")\n\n    matches = pattern.left.find(data)\n    for match in matches:\n        new_value = match.value\n        idxs = [pattern.right.index] if isinstance(pattern.right, Index) \\\n            else pattern.right.reified_fields(match.context)\n        for idx in idxs:\n            del new_value[idx]\n        parse(str(match.full_path)).update(data, new_value)\n\n    return data\n</code></pre>"},{"location":"api-reference/#sandhill.utils.jsonpath.eval_within","title":"<code>eval_within(string: str, context: dict)</code>","text":"<p>Given a string containing JSONPath queries, replace the queries with the values they found.</p> <p>JSONPath queries will query within the context.</p> <p>Example context </p> <pre><code>{\n    \"item\": {\n        \"elem1\": { \"elem2\": \"value1\" } }\n    \"parent\": {\n        \"elem3\": \"value2\" }\n}\n</code></pre> <p>Example query strings </p> <pre><code># No given context\n\"$.elem1.elem2\"     # would query the first item in the context dictionary\n# Specified conext\n\"$parent.elem3\"     # would query the the \"parent\" key in the context dictionary\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to search within for JSONPath queries </p> required <code>context</code> <code>dict</code> <p>A dictionary of contexts upon which a JSONPath could query.</p> required Source code in <code>sandhill/utils/jsonpath.py</code> <pre><code>def eval_within(string: str, context: dict):\n    '''\n    Given a string containing JSONPath queries, replace the queries with the values they found.\\n\n    JSONPath queries will query within the context.\\n\n    **Example context** \\n\n    ```json\n    {\n        \"item\": {\n            \"elem1\": { \"elem2\": \"value1\" } }\n        \"parent\": {\n            \"elem3\": \"value2\" }\n    }\n    ``` \\n\n    **Example query strings** \\n\n    ```python\n    # No given context\n    \"$.elem1.elem2\"     # would query the first item in the context dictionary\n    # Specified conext\n    \"$parent.elem3\"     # would query the the \"parent\" key in the context dictionary\n    ``` \\n\n    Args:\n        string (str): The string to search within for JSONPath queries \\n\n        context (dict): A dictionary of contexts upon which a JSONPath could query. \\n\n    '''\n    if not isinstance(context, dict) or len(context) == 0:\n        app.logger.debug(\"jsonpath.eval_within given invalid/empty context. Skipping.\")\n        return string\n\n    space_esc = '&amp;&amp;&amp;SPACE&amp;&amp;&amp;'\n    # find matching square brackets and replace spaces with placeholder\n    brackets = re.findall(r'(\\[.+?\\])', string)\n    for before, after in zip(brackets, [bkt.replace(' ', space_esc) for bkt in brackets]):\n        string = string.replace(before, after, 1)\n\n    parts = re.split(r'\\s', string)\n\n    # for vals starting with  $, JSONPath find and replace value with str() of result\n    jsonpath_pat = re.compile(r'^\\$([a-zA-Z0-9_]+)?\\.([^ ]+)$')\n    context_keys = list(context.keys())\n    for idx, part in enumerate(parts):\n        if (match := jsonpath_pat.match(part)):\n            ctx_key = match.group(1)\n            if not ctx_key:\n                ctx_key = context_keys[0]\n            path = f\"$.{match.group(2)}\".replace(space_esc, \" \")\n            result = find(context[ctx_key], path) if ctx_key in context else []\n            # If only one results, then remove it from list\n            result = result[0] if len(result) == 1 else result\n            result = json.dumps(result) if isinstance(result, str) else result\n            parts[idx] = result\n        else:\n            parts[idx] = part.replace(space_esc, \" \")\n\n    return \" \".join([str(part) for part in parts])\n</code></pre>"},{"location":"api-reference/#sandhill.utils.request","title":"<code>sandhill.utils.request</code>","text":"<p>Client request related functions</p>"},{"location":"api-reference/#sandhill.utils.request.match_request_format","title":"<code>match_request_format(view_args_key, allowed_formats, default_format='text/html')</code>","text":"<p>Match a request mimetype to the given view_args_key or the allowed mimetypes     provided by client. </p> <p>Parameters:</p> Name Type Description Default <code>view_args_key</code> <code>str | None</code> <p>the key in the url request to check within for             matching format. </p> required <code>allowed_formats</code> <code>list</code> <p>list of acceptable mimetypes. </p> required <code>default_format</code> <code>str</code> <p>the mimetype to use by default if view_args_key value is             not allowed. </p> <code>'text/html'</code> <p>Returns:</p> Name Type Description <code>result_format</code> <code>str</code> <p>the mimetype for the format to return.</p> Source code in <code>sandhill/utils/request.py</code> <pre><code>def match_request_format(view_args_key, allowed_formats, default_format='text/html'):\n    \"\"\"\n    Match a request mimetype to the given view_args_key or the allowed mimetypes \\\n    provided by client. \\n\n    Args:\n        view_args_key (str|None): the key in the url request to check within for \\\n            matching format. \\n\n        allowed_formats (list): list of acceptable mimetypes. \\n\n        default_format (str): the mimetype to use by default if view_args_key value is \\\n            not allowed. \\n\n    Returns:\n        result_format (str): the mimetype for the format to return. \\n\n    \"\"\"\n    result_format = default_format\n    # check for accept header\n    for mtype, _ in list(request.accept_mimetypes):\n        if mtype in allowed_formats:\n            result_format = mtype\n            break\n\n    # check for ext; e.g. search.json\n    if request.view_args and view_args_key in request.view_args:\n        mimetypes.init()\n        extension = \".\" + request.view_args[view_args_key]\n        if extension in mimetypes.types_map:\n            result_format = mimetypes.types_map[extension]\n\n    if result_format not in allowed_formats:\n        abort(501)\n\n    return result_format\n</code></pre>"},{"location":"api-reference/#sandhill.utils.request.overlay_with_query_args","title":"<code>overlay_with_query_args(query_config, request_args=None, *, allow_undefined=False)</code>","text":"<p>Given a query config, overlay request.args on the defaults to generate a combined     list of query arguments </p> <p>Parameters:</p> Name Type Description Default <code>query_config</code> <code>dict</code> <p>A dictionary containing rules for query args to parse, each key                              being a query arg name (e.g. \"arg_name\").</p> <p>Format for each key as below: </p> <pre><code>\"arg_name\": {\n    \"base\": [\"value\"]\n      -- Optional (str | list): value that cannot be changed by request.args; will\n         always be returned\n    \"default\": [\"overridable\"]\n      -- Optional (str | list): value which will be replaced by matching\n         requst.args, if passed\n}\n</code></pre> <p>Either \"base\" or \"default\" is required. If appropriate \"arg_name\" is not passed,             that \"arg_name\" will be filtered out. If \"default\" is not set, the request,arg             matching \"arg_name\" will be filtered out. Both \"base\" and \"default\" may be set at             the same time. In this case, only the \"default\" value will be able to be             overridded by requests.args; the \"base\" will remain unchanged. </p> required <code>request_args</code> <code>dict</code> <code>None</code> <code>allow_undefined</code> <code>bool</code> <p>If True, fields not defined in the query_config will be permitted </p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dict of the combined query arguments</p> Source code in <code>sandhill/utils/request.py</code> <pre><code>def overlay_with_query_args(query_config, request_args=None, *, allow_undefined=False):\n    \"\"\"\n    Given a query config, overlay request.args on the defaults to generate a combined \\\n    list of query arguments \\n\n    Args:\n        query_config (dict): A dictionary containing rules for query args to parse, each key \\\n                             being a query arg name (e.g. \"arg_name\").\\n\n            Format for each key as below: \\n\n            ```\n            \"arg_name\": {\n                \"base\": [\"value\"]\n                  -- Optional (str | list): value that cannot be changed by request.args; will\n                     always be returned\n                \"default\": [\"overridable\"]\n                  -- Optional (str | list): value which will be replaced by matching\n                     requst.args, if passed\n            }\n            ``` \\n\n            Either \"base\" or \"default\" is required. If appropriate \"arg_name\" is not passed, \\\n            that \"arg_name\" will be filtered out. If \"default\" is not set, the request,arg \\\n            matching \"arg_name\" will be filtered out. Both \"base\" and \"default\" may be set at \\\n            the same time. In this case, only the \"default\" value will be able to be \\\n            overridded by requests.args; the \"base\" will remain unchanged. \\n\n        request_args (dict):\n        allow_undefined (bool): If True, fields not defined in the query_config will be permitted \\n\n    Returns:\n        (dict): A dict of the combined query arguments \\n\n    \"\"\"\n    # grab the query string params and convert to a flat dict if request args not passed in\n    # i.e. duplicative keys will be converted to a list of strings\n    if request_args is None:\n        request_args = {}\n\n    # avoid modifying incoming args dict and always allow url override (config to be enforced next)\n    request_args = deepcopy(request_args) | request.args.to_dict(flat=False)\n\n    query_params = {}\n    for field_name, field_conf in query_config.items():\n        query_params[field_name] = []\n        # Load base from config\n        if 'base' in field_conf:\n            query_params[field_name] = field_conf['base']\n        # Load from request_args\n        if field_name in request_args:\n            # Allow override if field defined with a default\n            if 'default' in field_conf and field_conf['default'] is not None:\n                query_params[field_name] = touniquelist(\n                    query_params[field_name],\n                    request_args[field_name]\n                )\n            # Remove field from request_args having already processed it\n            del request_args[field_name]\n        # Load default from config if solr_param field not defined in request_args\n        elif 'default' in field_conf:\n            query_params[field_name] = touniquelist(\n                query_params[field_name],\n                field_conf['default']\n            )\n        # Remove field from solr query if empty\n        if not any(query_params[field_name]):\n            del query_params[field_name]\n\n        # restrictions\n        #TODO something like: query_params[field_name] = apply_restrictions(\n        #    query_params[field_name], field_conf['restrictions'])\n        # Anyone who puts a negative number in rows or (any other non integer) will\n        # get what they deserve. \"-1\" for instance will return the max\n        # number of search results.\n        if 'max' in field_conf:\n            query_params[field_name] = [\n                val if str(val).isdigit() and int(val) &lt; int(field_conf['max'])\n                else str(field_conf['max']) for val in query_params[field_name]\n            ]\n        if 'min' in field_conf:\n            query_params[field_name] = [\n                val if str(val).isdigit() and int(val) &gt; int(field_conf['min'])\n                else str(field_conf['min']) for val in query_params[field_name]\n            ]\n\n    if allow_undefined:\n        query_params.update(request_args)\n\n    return query_params\n</code></pre>"},{"location":"api-reference/#utilssolrsolr","title":"<code>utils.solr.Solr</code>","text":"<p>Class for handling Solr related logic, such as encoding/decoding.</p>"},{"location":"api-reference/#sandhill.utils.template","title":"<code>sandhill.utils.template</code>","text":"<p>Template and Jinja2 utilities</p>"},{"location":"api-reference/#sandhill.utils.template.evaluate_conditions","title":"<code>evaluate_conditions(conditions, ctx, match_all=True)</code>","text":"<p>Render each conditions' <code>evaluate</code> using the given context; the result must     match a value in the conditions' <code>match_when</code> or none of the conditions' <code>match_when_not</code>. </p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>list</code> <p>List of dict containing keys 'value' and 'allowed' </p> required <code>ctx</code> <code>dict</code> <p>Context dictionary for template variables </p> required <code>match_all</code> <code>bool</code> <p>If all conditions need to be matched for it to be considered             a match. </p> <p>Default: True </p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>returns the number of matches matched ONLY if all are matched, else returns 0 </p> <p>Raises:</p> Type Description <code>KeyError</code> <p>when \"match_when\"/\"match_when_not\" or \"evaluate\" is not in conditions</p> Source code in <code>sandhill/utils/template.py</code> <pre><code>def evaluate_conditions(conditions, ctx, match_all=True):\n    \"\"\"\n    Render each conditions' `evaluate` using the given context; the result must \\\n    match a value in the conditions' `match_when` or none of the conditions' `match_when_not`. \\n\n    Args:\n        conditions (list): List of dict containing keys 'value' and 'allowed' \\n\n        ctx (dict): Context dictionary for template variables \\n\n        match_all (bool): If all conditions need to be matched for it to be considered \\\n            a match. \\n\n            Default: True \\n\n    Returns:\n        (int): returns the number of matches matched ONLY if all are matched, else returns 0 \\n\n    Raises:\n        KeyError: when \"match_when\"/\"match_when_not\" or \"evaluate\" is not in conditions \\n\n    \"\"\"\n    matched = 0\n    for match in conditions:\n        # Idea: use boosts if the matched value for 2 config files is the same,\n        # e.g. matched += boost\n        check_value = render_template_string(match['evaluate'], ctx)\n        if not any(key in ['match_when', 'match_when_not'] for key in match.keys()) or \\\n            {'match_when', 'match_when_not'}.issubset(set(match.keys())):\n            raise KeyError(\n                \"One (and only one) of the keys 'match_when' or 'match_when_not' must be present\"\n            )\n        if 'match_when' in match and check_value in match['match_when']:\n            matched += 1\n        elif 'match_when_not' in match and check_value not in match['match_when_not']:\n            matched += 1\n    # Only assigned matched value if ALL matches are successful\n    return matched if matched == len(conditions) or not match_all else 0\n</code></pre>"},{"location":"api-reference/#sandhill.utils.template.render_template_json","title":"<code>render_template_json(json_obj, ctx)</code>","text":"<p>Serialize a JSON, render it as a template, then convert back to JSON </p> <p>Parameters:</p> Name Type Description Default <code>json_obj</code> <code>dict | list</code> <p>JSON represented in Python </p> required <code>ctx</code> <code>dict</code> <p>Context for the jinja template </p> required <p>Returns:</p> Type Description <code>dict | list</code> <p>The updated JSON structure </p> <p>Raises:</p> Type Description <code>JSONDecodeError</code> <p>If the resulting templace is unable to be parsed as JSON</p> Source code in <code>sandhill/utils/template.py</code> <pre><code>def render_template_json(json_obj, ctx):\n    \"\"\"\n    Serialize a JSON, render it as a template, then convert back to JSON \\n\n    Args:\n        json_obj (dict|list): JSON represented in Python \\n\n        ctx (dict): Context for the jinja template \\n\n    Returns:\n        (dict|list): The updated JSON structure \\n\n    Raises:\n        json.JSONDecodeError: If the resulting templace is unable to be parsed as JSON \\n\n    \"\"\"\n    # Disable autoescape for JSON output to avoid HTML entities being injected\n    rendered = render_template_string(\n        \"{% autoescape false -%}\" +\n        json.dumps(json_obj) +\n        \"{%- endautoescape %}\",\n        ctx\n    )\n    return json.loads(rendered)\n</code></pre>"},{"location":"api-reference/#sandhill.utils.template.render_template_string","title":"<code>render_template_string(template_str, ctx)</code>","text":"<p>Renders Jinja templates with added Sandhill filters/context processors. </p> <p>Parameters:</p> Name Type Description Default <code>template_str</code> <code>string</code> <p>jinja template variable </p> required <code>ctx</code> <code>dict</code> <p>Context for the jinja template </p> required <p>Returns:</p> Type Description <code>str</code> <p>The rendered template as a string. </p> <p>Raises:</p> Type Description <code>TemplateError</code> <p>On invalid template.</p> Source code in <code>sandhill/utils/template.py</code> <pre><code>def render_template_string(template_str, ctx):\n    \"\"\"\n    Renders Jinja templates with added Sandhill filters/context processors. \\n\n    Args:\n        template_str (string): jinja template variable \\n\n        ctx (dict): Context for the jinja template \\n\n    Returns:\n        (str): The rendered template as a string. \\n\n    Raises:\n        jinja2.TemplateError: On invalid template. \\n\n    \"\"\"\n    with context.app_context():\n        return flask.render_template_string(template_str, **ctx)\n</code></pre>"},{"location":"api-reference/#sandhill.utils.test","title":"<code>sandhill.utils.test</code>","text":"<p>Dummy functions for use in unit tests.</p>"},{"location":"api-reference/#sandhill.utils.xml","title":"<code>sandhill.utils.xml</code>","text":"<p>XML loading and handling functionality.</p>"},{"location":"api-reference/#sandhill.utils.xml.load","title":"<code>load(source, timeout=None) -&gt; etree._Element</code>","text":"<p>Load an XML document. </p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>XML source. Either path, url, string, or loaded LXML Element </p> required <code>timeout</code> <p>An integer timeout in seconds; defaults to 10 if not set</p> <code>None</code> <p>Returns:     Loaded XML object tree, or None on invalid source or timeout</p> Source code in <code>sandhill/utils/xml.py</code> <pre><code>@catch(etree.XMLSyntaxError, \"Invalid XML source: {source} Exc: {exc}\", return_val=None)\n@catch(RequestException, \"XML API call failed: {source} Exc: {exc}\", return_val=None)\n@catch(RequestsConnectionError, \"Invalid host in XML call: {source} Exc: {exc}\", return_val=None)\ndef load(source, timeout=None) -&gt; etree._Element: # pylint: disable=protected-access\n    '''\n    Load an XML document. \\n\n    Args:\n        source: XML source. Either path, url, string, or loaded LXML Element \\n\n        timeout: An integer timeout in seconds; defaults to 10 if not set\n    Returns:\n        Loaded XML object tree, or None on invalid source or timeout \\n\n    '''\n    if timeout is None:\n        timeout = 10\n    if not isinstance(source, (str, bytes)) or len(source) &lt; 1:\n        # pylint: disable=protected-access\n        return source if isinstance(source, etree._ElementTree) else None\n\n    source = source.strip()\n    if source[0] == ord('&lt;'):           # Handle source as bytes\n        source = io.BytesIO(source)\n    elif source[0] == '&lt;':              # Handle source as string\n        source = io.StringIO(source)\n    elif checkers.is_file(source):      # Handle source as local file\n        pass  # etree.parse handles local file paths natively\n    elif checkers.is_url(source):       # Handle source as URL\n        response = requests.get(source, timeout=timeout)\n        if not response:\n            app.logger.warning(f\"Failed to retrieve XML URL (or timed out): {source}\")\n            return None\n        source = io.BytesIO(response.content)\n    else:\n        app.logger.warning(f\"XML source is not valid file, URL, or XML string. {source[:40]}\"\n                           + (len(source) &gt; 40) * '...')\n        return None\n\n    return etree.parse(source)\n</code></pre>"},{"location":"api-reference/#sandhill.utils.xml.xpath","title":"<code>xpath(source, query, timeout=None) -&gt; list</code>","text":"<p>Retrieve the matching xpath content from an XML source </p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>XPath query to match against </p> required <code>source</code> <p>XML source. Either path, url, or string </p> required <p>Returns:</p> Type Description <code>list</code> <p>Matching results from XPath query, or None on failure</p> Source code in <code>sandhill/utils/xml.py</code> <pre><code>@catch(etree.XPathEvalError, \"Invalid XPath query {query} Exc {exc}\", return_val=None)\ndef xpath(source, query, timeout=None) -&gt; list:\n    '''\n    Retrieve the matching xpath content from an XML source \\n\n    Args:\n        query (str): XPath query to match against \\n\n        source: XML source. Either path, url, or string \\n\n    Returns:\n        Matching results from XPath query, or None on failure \\n\n    '''\n    doc = load(source, timeout)\n    return doc.xpath(query, namespaces=doc.getroot().nsmap) if doc else None\n</code></pre>"},{"location":"api-reference/#sandhill.utils.xml.xpath_by_id","title":"<code>xpath_by_id(source, query) -&gt; dict</code>","text":"<p>For the matching xpath content, organize into dict with key     being the id param of the matched tags. Elements without an id attribute     will not be returned. </p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>XPath query to match against </p> required <code>source</code> <p>XML source. Either path, url, or string </p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>Dict mapping with keys of id, and values of content within                      matching elements, or None on failure</p> Source code in <code>sandhill/utils/xml.py</code> <pre><code>def xpath_by_id(source, query) -&gt; dict:\n    '''\n    For the matching xpath content, organize into dict with key \\\n    being the id param of the matched tags. Elements without an id attribute \\\n    will not be returned. \\n\n    Args:\n        query (str): XPath query to match against \\n\n        source: XML source. Either path, url, or string \\n\n    Returns:\n        (dict|None): Dict mapping with keys of id, and values of content within \\\n                     matching elements, or None on failure \\n\n    '''\n    matched = xpath(source, query)\n    if matched is None: # Explicit check to avoid empty results being matched\n        return None\n\n    idmap = {}\n    for match in matched:\n        if 'id' in match.keys():\n            text = match.text if match.text is not None else ''\n            for elem in match.iterchildren():\n                text += etree.tostring(elem, encoding='unicode')\n            text += match.tail if match.tail is not None else ''\n            idmap[match.get('id')] = text\n    return idmap\n</code></pre>"},{"location":"api-reference/#bootstrap","title":"Bootstrap","text":"<p>This is the code that starts up Sandhill, initializing the application. Have a look at the bootstrap documentation for more details.</p>"},{"location":"api-reference/#bootstrap_1","title":"<code>bootstrap</code>","text":"<p>The core of the bootstrap module handles, among other things, loading other Python code.</p>"},{"location":"api-reference/#bootstraprequest","title":"<code>bootstrap.request</code>","text":"<p>Standard changes Sandhill makes to the default Flask <code>request</code> object.</p> <p>Specifically, it:</p> <ul> <li>Adds <code>query_args</code>, a normal Python dictionary with args as keys.</li> </ul>"},{"location":"api-reference/#bootstrapg","title":"<code>bootstrap.g</code>","text":"<p>Standard changes Sandhill makes to the default Flask <code>g</code> object.</p> <p>Specifically, it:</p> <ul> <li>Adds <code>instance_path</code> available in <code>g</code> object.</li> </ul>"},{"location":"api-reference/#bootstrapdebugtoolbar","title":"<code>bootstrap.debugtoolbar</code>","text":"<p>Bootstrap hook to add FlaskDebugToolbar to the Flaks application when debug mode is enabled.</p>"},{"location":"api-reference/#bootstrapdisable_debug_caching","title":"<code>bootstrap.disable_debug_caching</code>","text":""},{"location":"api-reference/#sandhill.bootstrap.disable_debug_caching.disable_browser_cache","title":"<code>sandhill.bootstrap.disable_debug_caching.disable_browser_cache(response)</code>","text":"<p>Adds headers to disable browser caching when app is in debug mode.</p> Source code in <code>sandhill/bootstrap/disable_debug_caching.py</code> <pre><code>@app.after_request\ndef disable_browser_cache(response):\n    \"\"\"Adds headers to disable browser caching when app is in debug mode.\"\"\"\n    if app.debug:\n        response.headers[\"Cache-Control\"] = \"no-cache, no-store, must-revalidate\"\n        response.headers[\"Pragma\"] = \"no-cache\"\n        response.headers[\"Expires\"] = 0\n    return response\n</code></pre>"},{"location":"bootstrap/","title":"Sandhill's Bootstrap Process","text":"<p>The bootstrap process is how Sandhill initializes itself and starts running, and is done before any requests are able to be served. This whole process takes only a few seconds and runs automatically.</p>"},{"location":"bootstrap/#bootstrap-steps","title":"Bootstrap Steps","text":"<ol> <li>The Flask application is created</li> <li>Core bootstrap functionality initiated<ul> <li>Include <code>instance/</code> path for templates and static path routes</li> <li>Load the <code>sandhill.cfg</code> config file</li> <li>Configure logging</li> </ul> </li> <li>Load code from both core Sandhill and the site instance (in that order for each item)<ul> <li>Bootstrap files in <code>bootstrap/</code></li> <li>Command files from <code>commands/</code></li> <li>Template filters from <code>filters/</code></li> <li>Context functionality from <code>context/</code></li> </ul> </li> <li>Load routes from <code>instance/config/routes/</code></li> </ol>"},{"location":"bootstrap/#adding-instance-bootstrap-code","title":"Adding Instance Bootstrap Code","text":"<p>Adding code specific to your instance into Sandhill is as simple as placing your code into one of the appropriate directories:</p> <ul> <li><code>instance/bootstrap/</code></li> <li><code>instance/commands/</code></li> <li><code>instance/filters/</code></li> <li><code>instance/context/</code></li> </ul> <p>There is technically no difference between the above directories other than the order in which they are loaded. Any Python (<code>.py</code>) file located in the above directories will be auto-loaded upon Sandhill's start.</p> <p>Adding or editing a Python file located in the above after Sandhill has started will not be loaded until Sandhill is restarted.</p>"},{"location":"bootstrap/#core-sandhill-bootstrap-files","title":"Core Sandhill Bootstrap Files","text":"<p>If you're curious, have a look at the bootstrap source code of Sandhill over at the API reference page.</p>"},{"location":"data-processors/","title":"Sandhill Data Processors","text":"<p>Sandhill routes are composed of a list of data processors. These are single actions that Sandhill may take while processing a request.</p> <p>Things data processors can do:</p> <ul> <li>Gathering data by querying an API</li> <li>Loading configuration from a file</li> <li>Transforming or manipulating data</li> <li>Performing some evaluation or computation</li> </ul> <p>If the data processors provided with Sandhill are not sufficient, you can develop your own data processor as well.</p>"},{"location":"data-processors/#data-processors-included-with-sandhill","title":"Data Processors Included With Sandhill","text":"<ul> <li>evaluate - Evaluate a set of conditions and return a truthy result.</li> <li>file - Find and load files from the instance.</li> <li>iiif - Calls related to IIIF APIs.</li> <li>request - Do generic API calls and redirects.</li> <li>solr - Calls to a Solr endpoint.</li> <li>stream - Stream data to client from a previously open connection.</li> <li>string - Simple string manipualtion.</li> <li>template - Render files or strings through Jinja templating.</li> <li>xml - Load XML or perform XPath queries.</li> </ul>"},{"location":"data-processors/#common-data-processor-arguments","title":"Common Data Processor Arguments","text":"<p>These arguments are valid to pass to all data processors. Data processors should be written to handle these arguments appropriately.  </p>"},{"location":"data-processors/#name-required","title":"<code>name</code> - Required","text":"<p>Defines the label under which the data processor will run. Results from the processor will be stored under this key in the data passed to subsequent processors.  </p>"},{"location":"data-processors/#processor-required","title":"<code>processor</code> - Required","text":"<p>Specifies the processor and method to call within the processor, period delimited. <pre><code>{\n    \"name\": \"searchresults\",\n    \"processor\": \"solr.search\"\n}\n</code></pre></p>"},{"location":"data-processors/#on_fail-optional","title":"<code>on_fail</code> - Optional","text":"<p>Unless specified, the data processor is allowed to fail silently and proceed onto the next processor. When specified, the value must be the integer of a valid 4xx or 5xx HTTP Status Code or <code>0</code>. If the data processor fails and <code>on_fail</code> set, Sandhill will abort the page request and return an error page with the selected code. If set to <code>0</code>, the processor may choose to return an appropriate code to the type of failure.  </p>"},{"location":"data-processors/#when-optional","title":"<code>when</code> - Optional","text":"<p>A string which is first rendered through Jinja and then evaluated for truth. If the value is not truthy, then the given data processor will be skipped.  </p>"},{"location":"data-processors/#sandhill.processors.evaluate","title":"<code>sandhill.processors.evaluate</code>","text":"<p>Processor for evaluation functions</p>"},{"location":"data-processors/#sandhill.processors.evaluate.conditions","title":"<code>conditions(data)</code>","text":"<p>Evaluates the conditions specified in the processor section of the configs.</p> <p>Detailed documentation </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>conditions</code> string: Indicates the location in <code>data</code> where conditions to be                 evaluated are.</p> <p>This is a <code>.</code> delimited string of dict keys and/or list indexes.</p> </li> <li> <p><code>match_all</code> _boolean__: Whether to require all conditions to match for success;                 if false, any single match will be considered a success.</p> </li> <li> <p><code>abort_on_match</code> boolean, optional: If true, then trigger an abort when the                 conditions are truthy.</p> </li> </ul> required <p>Returns:</p> Type Description <code>bool | None</code> <p>Returns True if given conditions match appropriate to the                      parameters, False if they do not, or None on failure</p> <p>Raises:     HTTPException: If <code>abort_on_match</code> is true and the evaluation is truthy.</p> Source code in <code>sandhill/processors/evaluate.py</code> <pre><code>def conditions(data):\n    \"\"\"\n    Evaluates the conditions specified in the processor section of the configs.\\n\n    [Detailed documentation](https://msu-libraries.github.io/sandhill/evaluate-conditions/) \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `conditions` _string_: Indicates the location in `data` where conditions to be \\\n                evaluated are.\\n\n                This is a `.` delimited string of dict keys and/or list indexes.\\n\n            * `match_all` _boolean__: Whether to require all conditions to match for success; \\\n                if false, any single match will be considered a success.\\n\n            * `abort_on_match` _boolean, optional_: If true, then trigger an abort when the \\\n                conditions are truthy.\\n\n    Returns:\n        (bool|None): Returns True if given conditions match appropriate to the \\\n                     parameters, False if they do not, or None on failure\n    Raises:\n        HTTPException: If `abort_on_match` is true and the evaluation is truthy.\n    \"\"\"\n    # TODO refactor suggestion:\n    #   replace `match_all` with `match` key; new possible values:\n    #       \"all\"  : similar to match_all: True\n    #       \"any\"  : similar to match_all: False\n    #       \"none\" : new state which considers success when 0 matches\n    evaluation = None\n    condition_keys = ifnone(data, 'conditions', '')\n    _conditions = getdescendant(data, condition_keys if condition_keys else [])\n    if 'match_all' not in data or not isinstance(data['match_all'], bool):\n        app.logger.warning(\"Processor 'evaluate' is missing or has invalid 'match_all': \"\n                           + ifnone(data, 'match_all', \"not defined\"))\n    elif not _conditions:\n        ick = data['conditions'] if 'conditions' in data else \"'conditions' undefined\"\n        app.logger.warning(f\"Invalid condition keys: {ick}\")\n    else:\n        evaluation = evaluate_conditions(_conditions,\n                                         data, match_all=data['match_all']) &gt; 0\n        if 'abort_on_match' in data and data['abort_on_match'] and evaluation:\n            dp_abort(503)\n            evaluation = None\n\n    return evaluation\n</code></pre>"},{"location":"data-processors/#sandhill.processors.file","title":"<code>sandhill.processors.file</code>","text":"<p>Processing functions for files</p>"},{"location":"data-processors/#sandhill.processors.file.create_json_response","title":"<code>create_json_response(data)</code>","text":"<p>Wrapper for <code>load_json</code> that will return a JSON response object. </p> <p>This can be used to stream JSON instead of loading it to use it as data. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>path</code> string: A single file path to search for.</p> </li> <li> <p><code>paths</code> list: A list of file paths to search for.</p> </li> </ul> required <p>Returns:</p> Type Description <code>Response</code> <p>The response object with the JSON data loaded into it.</p> Source code in <code>sandhill/processors/file.py</code> <pre><code>def create_json_response(data):\n    '''\n    Wrapper for `load_json` that will return a JSON response object. \\n\n    This can be used to stream JSON instead of loading it to use it as data. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `path` _string_: A single file path to search for.\\n\n            * `paths` _list_: A list of file paths to search for.\\n\n    Returns:\n        (requests.Response): The response object with the JSON data loaded into it.\n    '''\n    resp = RequestsResponse()\n    resp.status_code = 200\n\n    content = load_json(data)\n    if content:\n        resp.raw = io.StringIO(json.dumps(content))\n    return resp\n</code></pre>"},{"location":"data-processors/#sandhill.processors.file.load_json","title":"<code>load_json(data)</code>","text":"<p>Search for files at the paths within 'path' and 'paths' keys of <code>data</code>.     Will load JSON from the first file it finds and then return the result. </p> <p>If both 'path' and 'paths' are set, paths from both will be searched     starting with 'path' first.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>path</code> string: A single file path to search for.</p> </li> <li> <p><code>paths</code> list: A list of file paths to search for.</p> </li> </ul> required <p>Returns:</p> Type Description <code>dict | None</code> <p>The loaded JSON data or None if no file was found.</p> <p>Note:     Paths must be relative to the <code>instance/</code> directory.</p> Source code in <code>sandhill/processors/file.py</code> <pre><code>def load_json(data):\n    '''\n    Search for files at the paths within 'path' and 'paths' keys of `data`. \\\n    Will load JSON from the first file it finds and then return the result. \\n\n    If both 'path' and 'paths' are set, paths from both will be searched \\\n    starting with 'path' first.\\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `path` _string_: A single file path to search for.\\n\n            * `paths` _list_: A list of file paths to search for.\\n\n    Returns:\n        (dict|None): The loaded JSON data or None if no file was found.\n    Note:\n        Paths must be relative to the `instance/` directory.\n    '''\n    file_data = None\n    # loop over each provided path and stop when one is found\n    if \"path\" in data:\n        data.setdefault(\"paths\", []).insert(0, data[\"path\"])\n    if \"paths\" in data:\n        for path in data[\"paths\"]:\n            full_path = os.path.join(app.instance_path, path.lstrip(\"/\"))\n            if os.path.exists(full_path):\n                file_data = load_json_config(full_path)\n                break\n    return file_data\n</code></pre>"},{"location":"data-processors/#sandhill.processors.file.load_matched_json","title":"<code>load_matched_json(data)</code>","text":"<p>Loads all the config files and returns the file that has the most     matched conditions. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li><code>location</code> string: A directory path within the instance                with JSON files containing <code>match_conditions</code> keys.</li> </ul> required <p>Returns:</p> Type Description <code>dict | None</code> <p>The loaded JSON data from the file that most matched its conditions,             or None if no files matched.</p> Source code in <code>sandhill/processors/file.py</code> <pre><code>def load_matched_json(data):\n    \"\"\"\n    Loads all the config files and returns the file that has the most \\\n    [matched conditions](#TODO). \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `location` _string_: A directory path within the instance \\\n               with JSON files containing `match_conditions` keys.\\n\n    Returns:\n        (dict|None): The loaded JSON data from the file that most matched its conditions, \\\n            or None if no files matched.\n    \"\"\"\n    file_data = None\n    matched_dict = {}\n    config_dir_path = None\n    if 'location' in data:\n        config_dir_path = os.path.join(app.instance_path, data['location'])\n\n    config_files = load_json_configs(config_dir_path, recurse=True)\n    for path, config in config_files.items():\n        if \"match_conditions\" in config:\n            try:\n                matched_dict[path] = evaluate_conditions(config['match_conditions'], data)\n            except KeyError:\n                app.logger.warning(\n                    f\"Missing 'evaluate' and/or 'match_when' for 'match_condition' in: {path}\")\n                continue\n    matched_path = max(matched_dict.items(), key=itemgetter(1))[0] if matched_dict else None\n\n    for path, score in matched_dict.items():\n        app.logger.debug(f\"load_matched_json(score={score}, path={path})\")\n\n    # Ensure number of matches is greater than 0\n    if matched_path in matched_dict and matched_dict[matched_path]:\n        app.logger.debug(f\"load_matched_json(matched={matched_path})\")\n        file_data = config_files[matched_path]\n\n    return file_data\n</code></pre>"},{"location":"data-processors/#sandhill.processors.iiif","title":"<code>sandhill.processors.iiif</code>","text":"<p>Processor for IIIF</p>"},{"location":"data-processors/#sandhill.processors.iiif.load_image","title":"<code>load_image(data, url=None, api_get_function=api_get)</code>","text":"<p>Load and return a IIIF image. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>route data where <code>data[view_ags][iiif_path]</code> and <code>data[identifier]</code> exist </p> required <code>url</code> <code>str</code> <p>Override the IIIF server URL from the default IIIF_BASE in the configs </p> <code>None</code> <code>api_get_function</code> <code>function</code> <p>function to use when making the GET request </p> <code>api_get</code> <p>Returns:</p> Type Description <code>Response | None</code> <p>Requested image from IIIF, or None on failure. </p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>On failure if <code>on_fail</code> is set.</p> Source code in <code>sandhill/processors/iiif.py</code> <pre><code>@catch(RequestException, \"Call to IIIF Server failed: {exc}\", abort=503)\ndef load_image(data, url=None, api_get_function=api_get):\n    '''\n    Load and return a IIIF image. \\n\n    Args:\n        data (dict): route data where `data[view_ags][iiif_path]` and `data[identifier]` exist \\n\n        url (str): Override the IIIF server URL from the default IIIF_BASE in the configs \\n\n        api_get_function (function): function to use when making the GET request \\n\n    Returns:\n        (requests.Response|None): Requested image from IIIF, or None on failure. \\n\n    Raises:\n        (HTTPException): On failure if `on_fail` is set. \\n\n    '''\n    image = None\n    url = establish_url(url, getconfig('IIIF_BASE', None))\n    if 'iiif_path' in data['view_args'] and 'identifier' in data:\n        image = api_get_function(\n            url=os.path.join(url, data['identifier'], data['view_args']['iiif_path']),\n            stream=True)\n    else:\n        app.logger.warning(\"Could not call IIIF Server; missing identifier or iiif_path\")\n        dp_abort(500)\n\n    if not image.ok:\n        app.logger.debug(f\"Call to IIIF Server returned {image.status_code}\")\n        dp_abort(image.status_code)\n        image = None\n    return image\n</code></pre>"},{"location":"data-processors/#sandhill.processors.request","title":"<code>sandhill.processors.request</code>","text":"<p>Processor for requests</p>"},{"location":"data-processors/#sandhill.processors.request.api_json","title":"<code>api_json(data)</code>","text":"<p>Make a call to an API and return the response content as JSON. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>url</code> str: The URL to make the API call to.</p> </li> <li> <p><code>method</code> str, optional: The HTTP method to use.</p> <p>Default: <code>\"GET\"</code> </p> </li> <li> <p><code>timeout</code> int, optional: The request timeout in seconds.</p> <p>Default: <code>10</code> </p> </li> </ul> required <p>Returns:</p> Type Description <code>dict</code> <p>The JSON response from the API call. </p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>On failure if <code>on_fail</code> is set.</p> Source code in <code>sandhill/processors/request.py</code> <pre><code>@catch(RequestException, \"Call to {data[url]} returned {exc}.\", abort=503)\ndef api_json(data):\n    '''\n    Make a call to an API and return the response content as JSON. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `url` _str_: The URL to make the API call to.\\n\n            * `method` _str, optional_: The HTTP method to use.\\n\n                Default: `\"GET\"` \\n\n            * `timeout` _int, optional_: The request timeout in seconds.\\n\n                Default: `10` \\n\n    Returns:\n        (dict): The JSON response from the API call. \\n\n    Raises:\n        (HTTPException): On failure if `on_fail` is set. \\n\n    '''\n    method = data['method'] if 'method' in data else 'GET'\n    app.logger.debug(f\"Connecting to {data['url']}\")\n    response = requests.request(\n        method=method,\n        url=data[\"url\"],\n        timeout=data.get('timeout', 10)\n    )\n\n    if not response.ok:\n        app.logger.warning(f\"Call to {data['url']} returned a non-ok status code: \" \\\n                           f\"{response.status_code}. {response.__dict__}\")\n        if 'on_fail' in data:\n            abort(response.status_code if data['on_fail'] == 0 else data['on_fail'])\n\n    try:\n        return response.json()\n    except JSONDecodeError:\n        app.logger.warning(f\"Call returned from {data['url']} that was not JSON.\")\n        dp_abort(503)\n        return {}\n</code></pre>"},{"location":"data-processors/#sandhill.processors.request.redirect","title":"<code>redirect(data)</code>","text":"<p>Trigger a redirect response to specified url. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> required <code>* `location` _str_</code> <p>URL to redirect client to.</p> required <code>* `code` _int, optional_</code> <p>HTTP status code to redirect with. </p> <p>Default: 302 </p> required <p>Returns:</p> Type Description <code>Response</code> <p>The flask response object with the included redirect. </p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the <code>location</code> key is not present.</p> Source code in <code>sandhill/processors/request.py</code> <pre><code>@catch(KeyError, \"Processor request.redirect called without a 'location' given.\", abort=500)\ndef redirect(data):\n    '''\n    Trigger a redirect response to specified url. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n        * `location` _str_: URL to redirect client to.\\n\n        * `code` _int, optional_: HTTP status code to redirect with. \\n\n            Default: 302 \\n\n    Returns:\n        (flask.Response): The flask response object with the included redirect. \\n\n    Raises:\n        (HTTPException): If the `location` key is not present. \\n\n    '''\n    code = data['code'] if 'code' in data else 302\n    return FlaskRedirect(data['location'], code=code)\n</code></pre>"},{"location":"data-processors/#sandhill.processors.solr","title":"<code>sandhill.processors.solr</code>","text":"<p>Wrappers for making API calls to a Solr node.</p>"},{"location":"data-processors/#sandhill.processors.solr.extension_callback_mapping","title":"<code>extension_callback_mapping() -&gt; dict</code>","text":"<p>Return the mapping with the form {extension: callback}. Args: Returns:     (dict): The dict containing the mapping in between extension and callback.</p> Source code in <code>sandhill/processors/solr.py</code> <pre><code>def extension_callback_mapping() -&gt; dict:\n    \"\"\"\n    Return the mapping with the form {extension: callback}.\n    Args:\n    Returns:\n        (dict): The dict containing the mapping in between extension and callback.\\n\n    \"\"\"\n    return {\n        # extension: callback\n        None: raw_parameter, # do nothing\n        'html': raw_parameter, # do nothing\n        'json': jsonify,\n        'csv': to_response,\n        'py': to_response,\n        'rb': to_response,\n        'xml': to_response,\n    }\n</code></pre>"},{"location":"data-processors/#sandhill.processors.solr.extension_writer_mapping","title":"<code>extension_writer_mapping() -&gt; dict</code>","text":"<p>Return the mapping with the form {extension: solr_writer}. Args: Returns:     (dict): The dict containing the mapping in between extension and writer.</p> Source code in <code>sandhill/processors/solr.py</code> <pre><code>def extension_writer_mapping() -&gt; dict:\n    \"\"\"\n    Return the mapping with the form {extension: solr_writer}.\n    Args:\n    Returns:\n        (dict): The dict containing the mapping in between extension and writer.\\n\n    \"\"\"\n    # extension: solr_writer\n    return {\n        None: 'json',\n        'html': 'json',\n        'json': 'json',\n        'csv': 'csv',\n        'py': 'python',\n        'rb': 'ruby',\n        # 'xlsx': 'xlsx', # needs additional solr config\n        'xml': 'xml',\n        # 'xslt': 'xslt', # seems to need additional solr config\n    }\n</code></pre>"},{"location":"data-processors/#sandhill.processors.solr.get_extension_callback","title":"<code>get_extension_callback(ext: str)</code>","text":"<p>Get the corresponding callback for the given extension. Args:     ext (str): The extension.</p> <p>Returns:</p> Type Description <code>str</code> <p>The corresponding callback to execute for this extension.</p> Source code in <code>sandhill/processors/solr.py</code> <pre><code>def get_extension_callback(ext: str):\n    \"\"\"\n    Get the corresponding callback for the given extension.\n    Args:\n        ext (str): The extension.\\n\n    Returns:\n        (str): The corresponding callback to execute for this extension.\\n\n    \"\"\"\n    # We already tested if it exists with is_valid_extension\n    return extension_callback_mapping()[ext]\n</code></pre>"},{"location":"data-processors/#sandhill.processors.solr.get_requested_extension","title":"<code>get_requested_extension(data) -&gt; str</code>","text":"<p>Extract the extension requested from the request (or modified by another processor). Args:     data (list): Processor arguments and all other data loaded from previous data processors.</p> <p>Returns:</p> Type Description <code>str</code> <p>The requested extension.</p> Source code in <code>sandhill/processors/solr.py</code> <pre><code>def get_requested_extension(data) -&gt; str:\n    \"\"\"\n    Extract the extension requested from the request (or modified by another processor).\n    Args:\n        data (list): Processor arguments and all other data loaded from previous data processors.\\n\n    Returns:\n        (str): The requested extension.\\n\n    \"\"\"\n    view_args = data.get('view_args')\n    return view_args.get('format') if view_args else None\n</code></pre>"},{"location":"data-processors/#sandhill.processors.solr.get_writer_from_extension","title":"<code>get_writer_from_extension(ext: str | None) -&gt; str</code>","text":"<p>Get the corresponding writer for the given extension. Args:     ext (str|any): The extension.</p> <p>Returns:</p> Type Description <code>str</code> <p>The solr writer.</p> Source code in <code>sandhill/processors/solr.py</code> <pre><code>def get_writer_from_extension(ext: str|None) -&gt; str:\n    \"\"\"\n    Get the corresponding writer for the given extension.\n    Args:\n        ext (str|any): The extension.\\n\n    Returns:\n        (str): The solr writer. \\n\n    \"\"\"\n    return extension_writer_mapping()[ext]\n</code></pre>"},{"location":"data-processors/#sandhill.processors.solr.is_valid_extension","title":"<code>is_valid_extension(ext: str) -&gt; bool</code>","text":"<p>Return if the given extension has corresponding mapping. Args:     ext (str): The extension.</p> <p>Returns:</p> Type Description <code>str</code> <p>True if the extension has corresponding mappings, False otherwise.</p> Source code in <code>sandhill/processors/solr.py</code> <pre><code>def is_valid_extension(ext: str) -&gt; bool:\n    \"\"\"\n    Return if the given extension has corresponding mapping.\n    Args:\n        ext (str): The extension.\\n\n    Returns:\n        (str): True if the extension has corresponding mappings, False otherwise.\\n\n    \"\"\"\n    return ext in extension_writer_mapping() and ext in extension_callback_mapping()\n</code></pre>"},{"location":"data-processors/#sandhill.processors.solr.raw_parameter","title":"<code>raw_parameter(param: any) -&gt; any</code>","text":"<p>Return the given parameter as passed. Args:     param (any): The parameter to get back.</p> <p>Returns:</p> Type Description <code>any</code> <p>The given parameter.</p> Source code in <code>sandhill/processors/solr.py</code> <pre><code>def raw_parameter(param: any) -&gt; any:\n    \"\"\"\n    Return the given parameter as passed.\n    Args:\n        param (any): The parameter to get back.\\n\n    Returns:\n        (any): The given parameter. \\n\n    \"\"\"\n    return param\n</code></pre>"},{"location":"data-processors/#sandhill.processors.solr.search","title":"<code>search(data, url=None, api_get_function=api_get)</code>","text":"<p>Perform a configured Solr search and return the result. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>path</code> string, <code>paths</code> list: The path to a search config file. Loaded               per file.load_json.</p> </li> <li> <p><code>params</code> dict: Query arguments to pass to Solr.</p> </li> <li> <p><code>record_keys</code> string, optional: Return this descendant path from               the response JSON. Default: <code>response.docs</code></p> </li> </ul> required <code>url</code> <code>str</code> <p>Overrides the default SOLR_URL normally retrieved from                    the Sandhill config file.</p> <code>None</code> <code>api_get_function</code> <code>function</code> <p>Function used to call Solr with. Used in unit tests.</p> <code>api_get</code> <p>Returns:</p> Type Description <code>dict | Response</code> <p>A dict of the loaded JSON response, or a <code>flask.Response</code> instance                                if <code>view_args.format</code> is <code>text/json</code>.</p> Source code in <code>sandhill/processors/solr.py</code> <pre><code>def search(data, url=None, api_get_function=api_get):\n    \"\"\"\n    Perform a [configured Solr search](#TODO) and return the result. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `path` _string_, `paths` _list_: The path to a search config file. Loaded \\\n              per [file.load_json](#TODO).\\n\n            * `params` _dict_: Query arguments to pass to Solr.\\n\n            * `record_keys` _string, optional_: Return this [descendant path](#TODO) from \\\n              the response JSON. Default: `response.docs`\\n\n        url (str): Overrides the default SOLR_URL normally retrieved from \\\n                   the [Sandhill config](#TODO) file.\\n\n        api_get_function (function): Function used to call Solr with. Used in unit tests.\\n\n    Returns:\n        (dict|flask.Response): A dict of the loaded JSON response, or a `flask.Response` instance \\\n                               if `view_args.format` is `text/json`. \\n\n    \"\"\"\n    # TODO module should return None and call dp_abort instead of abort\n    # TODO allow \"path\"\n    if 'paths' not in data or not data['paths']:\n        app.logger.error(\n            f\"Missing 'config' setting for processor \"\n            f\"'{data['processor']}' with name '{data['name']}'\")\n        abort(500)\n\n    # Load the search settings\n    search_config = load_json(data)\n    if 'solr_params' not in search_config:\n        app.logger.error(\n            f\"Missing 'solr_params' inside search config file(s) '{ str(data['paths']) }'\")\n        abort(500)\n    if 'config_ext' in data and 'solr_params' in data['config_ext']:\n        solr_config = recursive_merge(\n            search_config['solr_params'],\n            data['config_ext']['solr_params']\n        )\n    else:\n        solr_config = search_config['solr_params']\n\n    # override default parameters with request query parameters\n    data['params'] = overlay_with_query_args(solr_config,\n            request_args=data.get('params', None),\n            allow_undefined=True)\n\n    extension = get_requested_extension(data)\n    if not is_valid_extension(extension):\n        abort(501)\n    writer = get_writer_from_extension(extension)\n    data['params']['wt'] = writer\n    solr_results = select(data, url, api_get_function)\n\n    return get_extension_callback(extension)(solr_results)\n</code></pre>"},{"location":"data-processors/#sandhill.processors.solr.select","title":"<code>select(data, url=None, api_get_function=api_get)</code>","text":"<p>Perform a Solr select call and return the loaded JSON response. </p> <pre><code>\"name\": \"mysearch\",\n\"processor\": \"solr.select\",\n\"params\": { \"q\": \"*\", \"rows\":\"20\" }\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>params</code> dict: Query arguments to pass to Solr.</p> </li> <li> <p><code>record_keys</code> string, optional: Return this descendant path from               the response JSON.</p> </li> </ul> required <code>url</code> <code>str</code> <p>Overrides the default SOLR_URL normally retrieved from                    the Sandhill config file.</p> <code>None</code> <code>api_get_function</code> <code>function</code> <p>Function used to call Solr with. Used in unit tests.</p> <code>api_get</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>The loaded JSON data or None if nothing matched. </p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If <code>on_fail</code> is set.</p> Source code in <code>sandhill/processors/solr.py</code> <pre><code>@catch((RequestException, HTTPError), \"Call to Solr failed: {exc}\", abort=503)\n@catch(JSONDecodeError, \"Call returned from Solr that was not JSON.\", abort=503)\n@catch(KeyError, \"Missing url component: {exc}\", abort=400) # Missing 'params' key\ndef select(data, url=None, api_get_function=api_get):\n    \"\"\"\n    Perform a Solr select call and return the loaded JSON response. \\n\n    ```json\n    \"name\": \"mysearch\",\n    \"processor\": \"solr.select\",\n    \"params\": { \"q\": \"*\", \"rows\":\"20\" }\n    ``` \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `params` _dict_: Query arguments to pass to Solr.\\n\n            * `record_keys` _string, optional_: Return this [descendant path](#TODO) from \\\n              the response JSON.\\n\n        url (str): Overrides the default SOLR_URL normally retrieved from \\\n                   the [Sandhill config](#TODO) file.\\n\n        api_get_function (function): Function used to call Solr with. Used in unit tests.\\n\n    Returns:\n        (dict|None): The loaded JSON data or None if nothing matched. \\n\n    Raises:\n        wergzeug.exceptions.HTTPException: If `on_fail` is set. \\n\n    \"\"\"\n\n    url = establish_url(url, getconfig('SOLR_URL', None))\n    url = url + \"/select\"\n\n    # query solr with the parameters\n    app.logger.debug(f\"Connecting to {url}?{urlencode(data['params'])}\")\n    response = api_get_function(url=url, params=data['params'])\n    response_json = None\n    if not response.ok:\n        app.logger.warning(f\"Call to Solr returned {response.status_code}. {response}\")\n        try:\n            if 'error' in response.json():\n                app.logger.warning(\n                    f\"Error returned from Solr: {str(response.json()['error'])}\")\n        except JSONDecodeError:\n            pass\n        dp_abort(response.status_code)\n    else:\n        if 'wt' in data['params'] and data['params']['wt'] != 'json':\n            return response.text\n        response_json = response.json()\n        # Get the records that exist at the provided record_keys\n        if 'record_keys' in data and data['record_keys']:\n            response_json = getdescendant(response_json, data['record_keys'])\n\n    return response_json\n</code></pre>"},{"location":"data-processors/#sandhill.processors.solr.select_record","title":"<code>select_record(data, url=None, api_get_function=api_get)</code>","text":"<p>Perform a Solr select call and return the first result from the response. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>params</code> dict: Query arguments to pass to Solr.</p> </li> <li> <p><code>record_keys</code> string, optional: Return this descendant path from               the response JSON. Default: <code>response.docs</code></p> </li> </ul> required <code>url</code> <code>str</code> <p>Overrides the default SOLR_URL normally retrieved from the                    Sandhill config file.</p> <code>None</code> <code>api_get_function</code> <code>function</code> <p>Function used to call Solr with. Used in unit tests.</p> <code>api_get</code> <p>Returns:</p> Type Description <code>Any</code> <p>The first item matched by <code>record_keys</code> in the JSON response, otherwise None. </p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If <code>on_fail</code> is set.</p> Source code in <code>sandhill/processors/solr.py</code> <pre><code>def select_record(data, url=None, api_get_function=api_get):\n    \"\"\"\n    Perform a Solr select call and return the first result from the response. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `params` _dict_: Query arguments to pass to Solr.\\n\n            * `record_keys` _string, optional_: Return this [descendant path](#TODO) from \\\n              the response JSON. Default: `response.docs`\\n\n        url (str): Overrides the default SOLR_URL normally retrieved from the \\\n                   [Sandhill config](#TODO) file.\\n\n        api_get_function (function): Function used to call Solr with. Used in unit tests.\\n\n    Returns:\n        (Any): The first item matched by `record_keys` in the JSON response, otherwise None. \\n\n    Raises:\n        wergzeug.exceptions.HTTPException: If `on_fail` is set. \\n\n    \"\"\"\n    data['record_keys'] = ifnone(data, 'record_keys', 'response.docs')\n    records = select(data, url, api_get_function)\n\n    if records and isinstance(records, Sequence):\n        return records[0]\n    return None\n</code></pre>"},{"location":"data-processors/#sandhill.processors.stream","title":"<code>sandhill.processors.stream</code>","text":"<p>Processor for streaming data</p>"},{"location":"data-processors/#sandhill.processors.stream.response","title":"<code>response(data)</code>","text":"<p>Stream a Requests library response that was previously loaded. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>response</code> str: The key where the response is located.</p> </li> <li> <p>Key from <code>data[response]</code> requests.Response: The response to stream.</p> </li> </ul> required <p>Returns:</p> Type Description <code>Response | None</code> <p>A stream of the response </p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If <code>on_fail</code> is set.</p> Source code in <code>sandhill/processors/stream.py</code> <pre><code>def response(data):\n    '''\n    Stream a Requests library response that was previously loaded. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `response` _str_: The key where the response is located.\\n\n            * Key from `data[response]` _requests.Response_: The response to stream.\\n\n    Returns:\n        (flask.Response|None): A stream of the response \\n\n    Raises:\n        wergzeug.exceptions.HTTPException: If `on_fail` is set. \\n\n    '''\n    allowed_headers = [\n        'Content-Type', 'Content-Disposition', 'Content-Length',\n        'Range', 'accept-ranges', 'Content-Range'\n    ]\n    if 'response' not in data:\n        app.logger.error(\"stream.response requires a 'response' variable to be set.\")\n        abort(500)\n    resp = data[data[\"response\"]] if data[\"response\"] in data else None\n\n    # Not a valid response\n    if not isinstance(resp, RequestsResponse):\n        dp_abort(503)\n        return None\n    # Valid response, but not a success (bool check on resp fails if http code is 400 to 600)\n    if not resp:\n        dp_abort(resp.status_code)\n        return None\n\n    stream_response = FlaskResponse(\n        resp.iter_content(chunk_size=app.config['STREAM_CHUNK_SIZE']),\n        status=resp.status_code\n    )\n    for header in resp.headers.keys():\n        # Case insensitive header matching\n        if header.lower() in [allowed_key.lower() for allowed_key in allowed_headers]:\n            stream_response.headers.set(header, resp.headers.get(header))\n    return stream_response\n</code></pre>"},{"location":"data-processors/#sandhill.processors.stream.string","title":"<code>string(data)</code>","text":"<p>Stream a data variable as string data to the output </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>var</code> str: The name of the variable whose content should be sent.</p> </li> <li> <p><code>mimetype</code> str: The mimetype to send for the data (default: text/plain).</p> </li> </ul> required <p>Returns:</p> Type Description <code>Response | None</code> <p>A stream of the response</p> Source code in <code>sandhill/processors/stream.py</code> <pre><code>def string(data):\n    '''\n    Stream a data variable as string data to the output \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `var` _str_: The name of the variable whose content should be sent.\\n\n            * `mimetype` _str_: The mimetype to send for the data (default: text/plain).\\n\n    Returns:\n        (flask.Response|None): A stream of the response \\n\n    '''\n    if 'var' not in data or not data.get(data['var']):\n        app.logger.error(\"requires that 'var' is set to name of non-empty data variable\")\n        abort(500)\n    mimetype = data.get('mimetype', 'text/plain')\n\n    string_response = make_response(data.get(data['var']))\n    string_response.mimetype = mimetype\n    return string_response\n</code></pre>"},{"location":"data-processors/#sandhill.processors.string","title":"<code>sandhill.processors.string</code>","text":"<p>Processor for string functions</p>"},{"location":"data-processors/#sandhill.processors.string.replace","title":"<code>replace(data)</code>","text":"<p>For the given <code>name</code> in data, replace all occurances of an old string with new string and     return the result. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>name</code> str|requests.Response: The context in which to find and replace.</p> </li> <li> <p><code>old</code> str: The string to find.</p> </li> <li> <p><code>new</code> str: The string to replace it with.</p> </li> </ul> required <p>Returns:</p> Type Description <code>str | Response | None</code> <p>The same type as <code>data[name]</code> was, only now with string             replacements done. Or None if the 'name' value is None or missing.</p> Source code in <code>sandhill/processors/string.py</code> <pre><code>def replace(data):\n    '''\n    For the given `name` in data, replace all occurances of an old string with new string and \\\n    return the result. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `name` _str|requests.Response_: The context in which to find and replace.\\n\n            * `old` _str_: The string to find.\\n\n            * `new` _str_: The string to replace it with.\\n\n    Returns:\n        (str|requests.Response|None): The same type as `data[name]` was, only now with string \\\n            replacements done. Or None if the 'name' value is None or missing. \\n\n    '''\n    data_copy = deepcopy(data.get(data.get('name')))\n    cont_copy = data_copy if data_copy is not None else ''\n\n    # TODO able to handle regular string data (non-JSON)\n    # TODO handle FlaskResponse as well\n    if isinstance(data_copy, RequestsResponse):\n        cont_copy = data_copy.text\n    if cont_copy and not isinstance(cont_copy, str):\n        cont_copy = json.dumps(cont_copy)\n    cont_copy = cont_copy.replace(data['old'], data['new'])\n\n    # pylint: disable=protected-access\n    if isinstance(data_copy, RequestsResponse):\n        data_copy._content = cont_copy.encode()\n        data_copy.headers['Content-Length'] = len(data_copy._content)\n    elif cont_copy:\n        data_copy = json.loads(cont_copy)\n    return data_copy\n</code></pre>"},{"location":"data-processors/#sandhill.processors.template","title":"<code>sandhill.processors.template</code>","text":"<p>Processor for rendering templates</p>"},{"location":"data-processors/#sandhill.processors.template.render","title":"<code>render(data)</code>","text":"<p>Render the response as a template or directly as a Flask Response. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li><code>file</code> str: Path to the template file.</li> </ul> required <p>Returns:</p> Type Description <code>Response</code> <p>The rendered template in a Flask response. </p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If <code>file</code> is not set in data.</p> Source code in <code>sandhill/processors/template.py</code> <pre><code>@catch(TemplateError, \"An error has occured when rendering {data[file]}: {exc}\", abort=500)\n@catch(TemplateNotFound, \"Failure when rendering {data[file]}. \" \\\n       \"Could not find template to render: {exc}\", abort=501)\ndef render(data):\n    '''\n    Render the response as a template or directly as a Flask Response. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `file` _str_: Path to the template file.\\n\n    Returns:\n        (flask.Response): The rendered template in a Flask response. \\n\n    Raises:\n        wergzeug.exceptions.HTTPException: If `file` is not set in data. \\n\n    '''\n    if 'file' not in data:\n        app.logger.error(\"template.render: 'file' not set in data; unable to render response.\")\n        abort(500)\n    template = data[\"file\"]\n\n    return make_response(render_template(template, **data))\n</code></pre>"},{"location":"data-processors/#sandhill.processors.template.render_string","title":"<code>render_string(data)</code>","text":"<p>Given a Jinja2 template string, it will render that template to a string and set it in the <code>name</code> variable. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li><code>value</code> str: The template string to render.</li> </ul> required <p>Returns:</p> Type Description <code>str | None</code> <p>The rendered template string, or None if no <code>value</code> key was in data.</p> Source code in <code>sandhill/processors/template.py</code> <pre><code>@catch(TemplateError, \"Invalid template provided for: {data[value]}. Error: {exc}\",\n       return_val=None)\ndef render_string(data):\n    \"\"\"\n    Given a Jinja2 template string, it will render that template to a string and set it in\n    the `name` variable. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `value` _str_: The template string to render.\\n\n    Returns:\n        (str|None): The rendered template string, or None if no `value` key was in data. \\n\n    \"\"\"\n    evaluation = None\n    if 'value' in data:\n        evaluation = render_template_string(data['value'], data)\n    return evaluation\n</code></pre>"},{"location":"data-processors/#sandhill.processors.xml","title":"<code>sandhill.processors.xml</code>","text":"<p>XML Data Processors</p>"},{"location":"data-processors/#sandhill.processors.xml.load","title":"<code>load(data: dict) -&gt; etree._Element</code>","text":"<p>Load an XML document. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li><code>source</code> str: Either path, url, or string to load.</li> </ul> required <p>Returns:</p> Type Description <code>_Element | None</code> <p>The loaded XML object tree, or None if <code>source</code> not in data.</p> Source code in <code>sandhill/processors/xml.py</code> <pre><code>def load(data: dict) -&gt; etree._Element: # pylint: disable=protected-access\n    '''\n    Load an XML document. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `source` _str_: Either path, url, or string to load.\\n\n    Returns:\n        (lxml.etree._Element|None): The loaded XML object tree, or None if `source` not in data. \\n\n    '''\n    if 'source' not in data:\n        app.logger.warning(\"No source XML provided. Missing key: 'source'\")\n        return None\n    return xml.load(data['source'])\n</code></pre>"},{"location":"data-processors/#sandhill.processors.xml.xpath","title":"<code>xpath(data: dict) -&gt; list</code>","text":"<p>Retrieve the matching xpath content from an XML source. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>xpath</code> str: An XPath query.</p> </li> <li> <p><code>source</code> str: Either path, url, or string to load.</p> </li> </ul> required <p>Returns:</p> Type Description <code>list</code> <p>Matching results from XPath query, or None if any required keys are not in data.</p> Source code in <code>sandhill/processors/xml.py</code> <pre><code>def xpath(data: dict) -&gt; list:\n    '''\n    Retrieve the matching xpath content from an XML source. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `xpath` _str_: An XPath query.\\n\n            * `source` _str_: Either path, url, or string to load.\\n\n    Returns:\n        (list): Matching results from XPath query, or None if any required keys are not in data. \\n\n    '''\n    if 'xpath' not in data:\n        app.logger.warning(\"No xpath search provided. Missing key: 'xpath'\")\n        return None\n    return xml.xpath(load(data), data['xpath'])\n</code></pre>"},{"location":"data-processors/#sandhill.processors.xml.xpath_by_id","title":"<code>xpath_by_id(data: dict) -&gt; dict</code>","text":"<p>For the matching xpath content, organize into dict with key     being the id param of the matched tags. Elements without an id attribute     will not be returned. </p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Processor arguments and all other data loaded from previous data processors.</p> <ul> <li> <p><code>xpath</code> str: An XPath query.</p> </li> <li> <p><code>source</code> str: Either path, url, or string to load.</p> </li> </ul> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict mapping with keys of id, and values of content within matching elements,             or None if missing any required keys in data.</p> Source code in <code>sandhill/processors/xml.py</code> <pre><code>def xpath_by_id(data: dict) -&gt; dict:\n    '''\n    For the matching xpath content, organize into dict with key \\\n    being the id param of the matched tags. Elements without an id attribute \\\n    will not be returned. \\n\n    Args:\n        data (dict): Processor arguments and all other data loaded from previous data processors.\\n\n            * `xpath` _str_: An XPath query.\\n\n            * `source` _str_: Either path, url, or string to load.\\n\n    Returns:\n        (dict): Dict mapping with keys of id, and values of content within matching elements, \\\n            or None if missing any required keys in data. \\n\n    '''\n    if 'xpath' not in data:\n        app.logger.warning(\"No xpath search provided. Missing key: 'xpath'\")\n        return None\n    return xml.xpath_by_id(load(data), data['xpath'])\n</code></pre>"},{"location":"data-processors/#developing-a-data-processor","title":"Developing a Data Processor","text":"<p>Sandhill makes developing your own data processors quite easy, perhaps best explained with a simple example.  </p>"},{"location":"data-processors/#simple-processor","title":"Simple Processor","text":"<p>Within your <code>instance/</code> ensure there is <code>processors/</code> sub-directory. If not create it.</p> <p>Next create a new Python file in <code>instance/processors/</code>; we'll call our example file <code>myproc.py</code> (the name of the file is up to you). Next up, we create a function in that file which must accept a single parameter <code>data</code>. <pre><code># instance/processors/myproc.py\n\"\"\"The myproc data processors\"\"\"\n\ndef shout(data):\n    \"\"\"The shout data processor; will upper case all text and add an exlcaimation point.\"\"\"\n    ...\n</code></pre></p> <p>The <code>data</code> here is a dict containing all loaded data from a route up until this point. If previous data processors loaded anything, it will be present in <code>data</code>. Sandhill always includes the standard <code>view_args</code> key which contains any route variables. Also, all keys arguments set for this data processor call will also be in <code>data</code>.</p> <p>For our <code>shout()</code> processor, let's say we want to expect a key <code>words</code>, which will contain the data we want to transform with our processor.</p> <pre><code>def shout(data):\n    \"\"\"The shout data processor; will upper case all text and add an exlcaimation point.\"\"\"\n    return data[\"words\"].upper() + \"!\"\n</code></pre> <p>That's mostly it! Now we could include our custom data processor in a route with this entry in our route's JSON <code>data</code> list: <pre><code>{\n    \"name\": \"loudly\",\n    \"processor\": \"myproc.shout\",\n    \"words\": \"This is my statement\"\n}\n</code></pre></p> <p>And after the data processor runs, Sandhill will have the following in your route's <code>data</code> dict: <pre><code>{\n    \"data\": {\n        ... # other route data as may be appropriate\n        \"loudly\": \"THIS IS MY STATEMENT!\"\n    }\n}\n</code></pre></p>"},{"location":"data-processors/#improving-your-processor","title":"Improving your Processor","text":"<p>But what if someone fails to pass in the <code>words</code> key? Right now that would result in a <code>KeyError</code>.</p> <p>In Sandhill, best practice for data processors is to return <code>None</code> on most failures; that is unless the <code>on_fail</code> key is set in <code>data</code>. In this case, we ought to abort with the value of <code>on_fail</code>.</p> <p>To assist with this, Sandhill provide the <code>dp_abort()</code> function (short for \"data processor abort\") which will do most of the heavy lifting for you. Let's rework our method to handle failures. <pre><code>from sandhill.utils.error_handling import dp_abort\n\ndef shout(data):\n    \"\"\"The shout data processor; will upper case all text and add an exlcaimation point.\"\"\"\n    if \"words\" not in data:\n        # Here we choose HTTP status 500 for default, but `on_fail` value will take precedence.\n        dp_abort(500)\n        # If no `on_fail` is set, None indicates failure, so always return None after a db_abort().\n        return None\n    return data[\"words\"].upper() + \"!\"\n</code></pre></p> <p>With that, you have a nicely functioning data processor! For more advanced examples, feel free to peek at the source code of the built-in Sandhill data processors above.</p>"},{"location":"developing-your-instance/","title":"Development Guide","text":"<p>It is recommended to read the following documents before starting:</p> <ul> <li>Development Guidelines</li> <li>Instance Setup</li> </ul>"},{"location":"developing-your-instance/#creating-your-first-page","title":"Creating your first page","text":"<p>To get started building your own site using Sandhill, you will need to first create your instance. That <code>instance</code> directory will be where you start your development.</p> <p>Once you have your base instance directory structure setup you are ready to start writing <code>route</code> configs and their corrresponding <code>templates</code>.</p> <p>When writing your route config you will have the ability to set the url patterns that will resolve to that route config (ex: <code>\\home</code> or <code>\\item\\&lt;int:id&gt;</code>) and then create any number of data sections that can process input and getnerate output that can either be streamed or sent to a template file. These data sections can use any of the processors included with Sandhill or ones developed by you in the <code>instance/processors</code> directory.</p> <p>Assuming you've created a route that will resolve to a template, you can now move on to making that template with a name that matches what you provided in the route config. In that template, you will have full access to all Jinja2 filters and as well as all of the filters in Sandhill. See the official documentation for a more complete list of what you can do within Jinja. If you find a need for additional filters, you can add them in <code>instance/filters</code>.</p>"},{"location":"developing-your-instance/#testing","title":"Testing","text":"<p>Of course a very important part of any application is testing. Sandhill has included unit tests for all of it's components and we strongly encourage you to do the same for any custom components you write for your <code>instance</code>. These files should start with <code>test_</code> and be within a sub-directory called <code>tests</code> inside each relavent (ex: <code>instance/filters/tests/test_myfilter.py</code>).</p> <p>To run the unit tests simply run: <pre><code>env/bin/pytest\n</code></pre></p> <p>If you'd like to include functional tests for your pages, you can create a <code>instance/tests/pages.json</code> file which contains pages you'd like to test the responses from.</p> <p>An example of a few of those tests would be: <pre><code>[\n    {\n        \"page\": \"/\",\n        \"code\": 200,\n        \"contains\": [\n            \"It Works!\"\n        ]\n    },\n    {\n        \"_comment\": \"Testing that no errors appeared on the page\"\n        \"page\": \"/mypage\",\n        \"code\": 200,\n        \"excludes\": [\n            \"&lt;p&gt;Error&lt;/p&gt;\"\n        ]\n    },\n    {\n        \"page\": \"/path/does/not/exist\",\n        \"code\": 404\n    }\n]\n</code></pre></p> <p>To run the functional tests: <pre><code>env/bin/pytest -m functional\n</code></pre></p>"},{"location":"developing-your-instance/#contributing","title":"Contributing","text":"<p>If you feel any of the utilities you've written in your <code>instance</code> would be useful for other users in the community, you have the option of contributing back to Sandhill.</p>"},{"location":"development-guidelines/","title":"Code Standards","text":"<p>Here are the general guidelines for development in core Sandhill. You may wish to keep to these when developing your own instance code as well. If you plan on contributing code back to Sandhill, sticking to these guidelines will make the process much easier on us!</p>"},{"location":"development-guidelines/#file-naming","title":"File Naming","text":"<p>Python file names are to be in all lower case, and where required, will use an underscore (<code>_</code>) to separate words.</p>"},{"location":"development-guidelines/#imports","title":"Imports","text":"<p>Import statements are to include the full path instead of a relative path. <pre><code>from sandhill.processors import my_processor\n</code></pre></p>"},{"location":"development-guidelines/#code-design","title":"Code Design","text":"<p>Sandhill developers use <code>pylint</code> to verify syntax structure of all our code. The settings used are avalable in <code>.pylintrc</code> and you can run <code>pylint</code> on your Sandhill instance with the included <code>run-pylint</code> shell script.</p> <p>These are not hard requirements, but developers should strive to stay within the limitations raised by pylint if at all possible.</p>"},{"location":"development-guidelines/#code-style","title":"Code Style","text":"<p>In general, we will be following PEP 8 for code styling. Note that not all of these standards will not be captured through linting. </p> <p>For a quick reference see this grid.</p>"},{"location":"development-guidelines/#docstrings-style","title":"Docstrings Style","text":"<p>In general, we will be using the Google docstring style. </p> <p>One addition to these standards is to include the data type for all arguments and  return values. For example:</p> <pre><code>def getdescendant(obj, list_keys, extract=False, put=None):\n    \"\"\"\n    Gets key values from the dictionary/list if they exist;\n    will check recursively through the `obj`.\n    Args:\n        obj (dict|list): A dict/list to check, possibly containing nested dicts/lists.\n        list_keys (list|str): List of descendants to follow (or . delimited string)\n        extract (bool): If set to true, will remove the last matching value from the `obj`.\n        put (Any): Replace the found value with this new value in the `obj`,\n                   or append if the found value at a list key of `\"[]\"`\n    Returns:\n        (Any): The last matching value from list_keys, or None if no match\n    \"\"\"\n    ...\n</code></pre>"},{"location":"development-guidelines/#naming-conventions","title":"Naming Conventions","text":""},{"location":"development-guidelines/#files","title":"Files","text":"<ul> <li>Files should be named based on context rather than action(s) it may perform.</li> <li>E.g. A <code>commands/scss.py</code> with a <code>--compile</code> flag is preferred over <code>commands/compile_scss.py</code></li> <li>The context should not be overly broad.</li> </ul>"},{"location":"development-guidelines/#functionsmethods","title":"Functions/Methods","text":"<ul> <li>Function names should attempt to prefer shorter names when possible.</li> <li>Grammatically, function names should attempt one of the following structures:</li> <li><code>verb()</code></li> <li><code>noun()</code></li> <li><code>verb_noun()</code></li> <li>When additional context is appropriate, add a prefix to the function to indicate it:</li> <li><code>context_verb()</code></li> <li><code>context_noun()</code></li> <li><code>context_verb_noun()</code></li> <li>Functions should avoid specifying input types as part of the function name. Use documentation and type hinting instead.</li> <li>E.g. <code>to_widget()</code> is preferred over <code>convert_list_into_widget()</code></li> <li>Jinja filters and context processor should avoid understores:</li> <li>E.g. <code>setchildkey</code> is preferred to <code>set_child_key</code></li> </ul>"},{"location":"development-guidelines/#functionmethod-parameters","title":"Function/Method Parameters","text":"<ul> <li>Parameters should indicate what is to be passed rather than imply it.</li> <li>E.g. For a function accepting allowed tags, <code>tags</code> is preferred over <code>allow</code>. If multiple tag params would be accepted, then differentiate them like <code>tags_allowed</code> or <code>allowed_tags</code>.</li> <li>Boolean flags to function are discouraged, but it is understood they may be sometimes necessary.</li> <li>The number of boolean flags to functions should be minimal.</li> <li>Boolean flags should be keyword arguments only. This can be accomplished by disabling positional arguments using the <code>*</code> parameter.<ul> <li>E.g. <code>myfunc(param1, param2, *, myflag=False)</code> would require that <code>myflag</code> always be passed as a keyword argument</li> </ul> </li> </ul>"},{"location":"evaluate-conditions/","title":"Evaluate Conditions","text":"<p>Sandhill comes with a means of defining a complex true/false evaluation, which is sometimes useful when creating a site.</p> <p>This might be helpful if your site needs to:</p> <ul> <li>Determine if a resource is restricted or not.</li> <li>Select a different set of templates to display depending on context variables.</li> </ul> <p>Accessing the evaluate ability in Sandhill can be done via the <code>evaluate.conditions</code> data processor.</p>"},{"location":"evaluate-conditions/#example","title":"Example","text":"<p>Here is an example entry in our route's <code>data</code> list for the <code>evaluate.conditions</code> processor. <pre><code>{\n  \"name\": \"myeval\",\n  \"processor\": \"evaluate.conditions\",\n  \"conditions\": \"access_checks.record\",\n  \"match_all\": true\n}\n</code></pre> The <code>conditions</code> indicates where in our <code>data</code> to search for the list of conditions to evaluate.</p> <p>The <code>match_all</code> set to <code>true</code> indicates that all of the conditions much be truthy in order for this evaluate to be considered a success (i.e. return <code>True</code>).</p> <p>Assume our <code>data</code> already has appropriate entries, such as: <pre><code>{\n  \"record\": { \"...\": \"...\" },\n  \"access_checks\": {\n    \"records\": [\n      {\n        \"evaluate\": \"{{ record.copyright_status }}\",\n        \"match_when\": [\"public domain\", \"permission granted\"]\n      },\n      {\n        \"evaluate\": \"{{ record.locked_status }}\",\n        \"match_when_not\": [\"unpublished\", \"editing\"]\n      },\n      {\n        \"evaluate\": \"{{ record.title | length &gt; 0 }}\",\n        \"match_when\": [\"True\"]\n      }\n    ]\n  }\n}\n</code></pre></p> <p>There three conditions to check above within the <code>access_checks.records</code> keys indicated by our <code>conditions</code> value.</p> <p>Each condition must have:</p> <ul> <li>An <code>evaluate</code> key with a string expression. All <code>evaluate</code> expressions will be rendered by Jinja before being checked against.</li> <li>Either of:</li> <li>A <code>match_when</code> key containing a list of values, one of which must equal the rendered <code>evaluate</code> to be considered a success.</li> <li>A <code>match_when_not</code> key containing a list of values, none of which must equal the rendered <code>evaluate</code> to be considered a success.</li> </ul> <p>As we have <code>match_all</code> set to <code>true</code>, all three of our above conditions much succeed in order for our <code>evaluate.conditions</code> data processor return <code>True</code>. If any condition is not true, the whole data processor will return <code>False</code>. If we only cared that any single condition be true, we could set <code>match_all</code> to <code>false</code>.</p>"},{"location":"evaluate-conditions/#abort-on-match","title":"Abort on Match","text":"<p>You can optionally have Sandhill instantly abort if an <code>evaluate.conditions</code> is successful by setting <code>abort_on_match</code> in your data processor entry to <code>true</code>.</p> <pre><code>{\n  \"name\": \"myeval\",\n  \"processor\": \"evaluate.conditions\",\n  \"conditions\": \"access_checks.record\",\n  \"match_all\": true,\n  \"abort_on_match\": true,\n  \"on_fail\": 401\n}\n</code></pre> <p>If the evaluate succeeds, Sandhill will trigger an abort to an error page. The default HTTP code is <code>503</code> but this can be customized by setting an <code>on_fail</code> for the data processor as seen in the above example.</p>"},{"location":"filters/","title":"Template Filters in Sandhill","text":"<p>Sandhill makes extensive use of the Jinja2 templating engine as included with Flask. Jinja expression are allowed in template files and many Sandhill config files.</p> <p>In addition to filters available from Flask, and the ability to define your own filters, Sandhill provides a number of additional filters ready for use, all of which are listed below.</p> <ul> <li>Flask Built-in Filters</li> <li>Creating a Custom Filter</li> <li>Sandhill Provided Filters<ul> <li>General Purpose Filters</li> <li>Encoding/Formatting Filters</li> <li>Solr Filters</li> <li>Specialty Filters</li> </ul> </li> </ul>"},{"location":"filters/#creating-a-custom-filter","title":"Creating a Custom Filter","text":"<p>Sandhill has an easy way to integrate your own instance specific filters. Define your custom filters and save them in <code>instance/filters/</code>. Sandhill will automatically load all files placed there and any filtered defined will be available to your instance next time it's restarted.</p> <p>To create a custom filter is no different than any other filter in Sandhill. Lets create an example filter to ensure an exclamation point is at the end of a string.</p> <p>First we'll create a file to put it in: <code>instance/filters/myfilters.py</code>.</p> <p>Then we can proceed to write our filter: <pre><code>from sandhill import app\n\n@app.template_filter('exclam')\ndef exclam(value):\n    \"\"\"Returns the given value as a string, appending an exclamation mark if it\n    doesn't already end with one.\"\"\"\n    value = str(value)\n    if not value.endswith(\"!\"):\n        return f\"{value}!\"\n    return value\n</code></pre></p> <p>That is all there is to it! The new filter is ready to use in Sandhll, for example you can use: <code>{{ myval | exclam }}</code> within your template. Take a peek at the code for other Sandhill filters if you'd like to see more examples.</p>"},{"location":"filters/#general-purpose-filters","title":"General Purpose Filters","text":""},{"location":"filters/#sandhill.filters.filters.datepassed","title":"<code>datepassed(value)</code>","text":"<p>Checks if the embargoed date is greater than the current date </p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Date in the format yyy-mm-dd that needs to be checked </p> required <p>Returns:</p> Type Description <code>bool</code> <p>If the given date is less than the current date or not</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('datepassed')\n@catch((ValueError, TypeError),\n       'Unable to get a valid date in \"{value}\". Error {exc}', return_val=False)\ndef datepassed(value):\n    \"\"\"\n    Checks if the embargoed date is greater than the current date \\n\n    Args:\n        value (str): Date in the format yyy-mm-dd that needs to be checked \\n\n    Returns:\n        (bool): If the given date is less than the current date or not \\n\n    \"\"\"\n    value_date = datetime.strptime(value, \"%Y-%m-%d\")\n    current_date = datetime.now()\n    return value_date.date() &lt; current_date.date()\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.deepcopy","title":"<code>deepcopy(obj)</code>","text":"<p>Returns the deepcopy of the input object. </p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>dict | list | tuple</code> <p>The value to deepcopy. </p> required <p>Returns:</p> Type Description <code>dict | list | tuple</code> <p>The new copy of the variable.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('deepcopy')\ndef deepcopy(obj):\n    \"\"\"\n    Returns the deepcopy of the input object. \\n\n    Args:\n        obj (dict|list|tuple): The value to deepcopy. \\n\n    Returns:\n        (dict|list|tuple): The new copy of the variable. \\n\n    \"\"\"\n    return copy.deepcopy(obj)\n</code></pre>"},{"location":"filters/#getdescendant","title":"<code>getdescendant()</code>","text":"<p>Gets key values from the dictionary/list if they exist; will check recursively through the <code>obj</code>. Args:     obj (dict|list): A dict/list to check, possibly containing nested dicts/lists.     list_keys (list|str): List of descendants to follow (or . delimited string)     default (Any): Default value to return if no match found. Default of None. Returns:     (Any): The last matching value from list_keys, or default value if not match found.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('getdescendant')\ndef filter_getdescendant(obj, list_keys, default=None):\n    '''\n    Gets key values from the dictionary/list if they exist;\n    will check recursively through the `obj`.\n    Args:\n        obj (dict|list): A dict/list to check, possibly containing nested dicts/lists.\n        list_keys (list|str): List of descendants to follow (or . delimited string)\n        default (Any): Default value to return if no match found. Default of None.\n    Returns:\n        (Any): The last matching value from list_keys, or default value if not match found.\n    '''\n    found = getdescendant(obj, list_keys)\n    return default if found is None else found\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.getextension","title":"<code>getextension(value)</code>","text":"<p>For a given mimetype, return the appropriate file extension.</p> <p>Use: <code>\"image/jpeg\" | getextension</code> = <code>\"jpg\"</code> </p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>A mimetype string </p> required <p>Returns:</p> Type Description <code>str</code> <p>The matching filetype extension (without leading <code>.</code>) or <code>???</code> not found.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('getextension')\ndef getextension(value):\n    \"\"\"\n    For a given mimetype, return the appropriate file extension.\\n\n    Use: `\"image/jpeg\" | getextension` = `\"jpg\"` \\n\n    Args:\n        value (str): A mimetype string \\n\n    Returns:\n        (str): The matching filetype extension (without leading `.`) or `???` not found. \\n\n    \"\"\"\n    mimetypes.add_type(\"audio/wav\", '.wav')\n    extension = None\n    preferred = [\".txt\", \".jpg\", \".mp3\"]\n    all_extensions = mimetypes.guess_all_extensions(value)\n    if all_extensions:\n        for ext in all_extensions:\n            if ext in preferred:\n                extension = ext\n                break\n        if not extension:\n            extension = all_extensions[0]\n    else:\n        extension = \".???\"\n    return extension.upper()[1:]\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.head","title":"<code>head(value)</code>","text":"<p>Returns the head of the list if value is a non-empty list, otherwise returns the orig value. </p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Possible list from which to remove the first item from. </p> required <p>Returns:</p> Type Description <code>Any</code> <p>The first item from the list, or the original value if it was not a list.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('head')\ndef head(value):\n    \"\"\"\n    Returns the head of the list if value is a non-empty list, otherwise returns the orig value. \\n\n    Args:\n        value (Any): Possible list from which to remove the first item from. \\n\n    Returns:\n        (Any): The first item from the list, or the original value if it was not a list. \\n\n    \"\"\"\n    if isinstance(value, list) and value:\n        value = value[0]\n    return value\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.islist","title":"<code>islist(value)</code>","text":"<p>Check if given value is a list. </p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to type check against. </p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if value is a list.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('islist')\ndef islist(value):\n    \"\"\"\n    Check if given value is a list. \\n\n    Args:\n        value (Any): The value to type check against. \\n\n    Returns:\n        (bool): True if value is a list. \\n\n    \"\"\"\n    return isinstance(value, list)\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.regex_match","title":"<code>regex_match(value, pattern)</code>","text":"<p>Match the pattern in the value. Args:     value (str): value that the pattern will compare against     pattern (str): regex pattern that need to be checked Returns:     The regular expression match, as returned by <code>re.match()</code></p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('regex_match')\n@catch(re.error, \"Regex error in regex_match. {exc}\", return_val=None)\ndef regex_match(value, pattern):\n    \"\"\"\n    Match the pattern in the value.\n    Args:\n        value (str): value that the pattern will compare against\n        pattern (str): regex pattern that need to be checked\n    Returns:\n        The regular expression match, as returned by `re.match()`\n    \"\"\"\n    return re.match(pattern, value)\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.regex_sub","title":"<code>regex_sub(value, pattern, substitute)</code>","text":"<p>Substitute a pattern in the value. Args:     value (str): value that need the substitution     pattern (str): regex pattern that need to be checked     substitute (str): regex pattern that need to be substituted Returns:     (str): The value with patterns substituted</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('regex_sub')\n@catch(TypeError, \"Expected string in regex_sub. {exc}\", return_arg='value')\n@catch(re.error, \"Invalid regex supplied to regex_sub. {exc}\", return_arg='value')\ndef regex_sub(value, pattern, substitute):\n    \"\"\"\n    Substitute a pattern in the value.\n    Args:\n        value (str): value that need the substitution\n        pattern (str): regex pattern that need to be checked\n        substitute (str): regex pattern that need to be substituted\n    Returns:\n        (str): The value with patterns substituted\n    \"\"\"\n    return re.sub(pattern, substitute, value)\n</code></pre>"},{"location":"filters/#sandbug","title":"<code>sandbug()</code>","text":"<p>Writes a variable to the Sandhill debug logs. </p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Variable to write to the log. </p> required <code>comment</code> <code>str | None</code> <p>Optional comment to add to the log. </p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Always returns an empty string.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('sandbug')\ndef filter_sandbug(value: str, comment: str = None):\n    '''\n    Writes a variable to the Sandhill debug logs. \\n\n    Args:\n        value (str): Variable to write to the log. \\n\n        comment (str|None): Optional comment to add to the log. \\n\n    Returns:\n        (str): Always returns an empty string. \\n\n    '''\n    sandbug(value, comment) # pylint: disable=undefined-variable\n    return \"\"\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.setchildkey","title":"<code>setchildkey(parent_dict, parent_key, key, value)</code>","text":"<p>Take dictionary of url components, and update 'key' with 'value'.</p> <p>Use: <code>{'a': {'x': '1'}} | setchildkey('a', 'y', '2')</code> = <code>{'a': {'x': '1', 'y': '2'}}</code> </p> <p>Parameters:</p> Name Type Description Default <code>parent_dict</code> <code>dict</code> <p>dictionary to add parent_key to </p> required <code>parent_key</code> <code>str|int|other hashable type</code> <p>parent key to add to the parent_dict </p> required <code>key</code> <code>str|int|other hashable type</code> <p>key to put under parent_key </p> required <code>value</code> <code>any</code> <p>value to give that key </p> required <p>Returns:</p> Name Type Description <code>parent_dict</code> <code>dict</code> <p>The updated parent dictionary</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('setchildkey')\ndef setchildkey(parent_dict, parent_key, key, value):\n    \"\"\"\n    Take dictionary of url components, and update 'key' with 'value'.\\n\n    Use: `{'a': {'x': '1'}} | setchildkey('a', 'y', '2')` = `{'a': {'x': '1', 'y': '2'}}` \\n\n    Args:\n        parent_dict (dict): dictionary to add parent_key to \\n\n        parent_key (str|int|other hashable type): parent key to add to the parent_dict \\n\n        key (str|int|other hashable type): key to put under parent_key \\n\n        value (any): value to give that key \\n\n    Returns:\n        parent_dict (dict): The updated parent dictionary \\n\n    \"\"\"\n    if isinstance(parent_dict, dict) \\\n      and isinstance(parent_key, Hashable) \\\n      and isinstance(key, Hashable):\n        if parent_key not in parent_dict:\n            parent_dict[parent_key] = {}\n        parent_dict[parent_key][key] = value\n    return parent_dict\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.todict","title":"<code>todict(input_list: list)</code>","text":"<p>Convert a list into a dictionary, alternating key and value to create pairs. Args:     input_list (list): list with values to be converted into a dictionary Returns:     (dict): The new dictionary</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('todict')\ndef todict(input_list: list):\n    \"\"\"\n    Convert a list into a dictionary, alternating key and value to create pairs.\n    Args:\n        input_list (list): list with values to be converted into a dictionary\n    Returns:\n        (dict): The new dictionary\n    \"\"\"\n    return dict(totuples(input_list, 2))\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.totuples","title":"<code>totuples(input_list: list, tuple_length: int)</code>","text":"<p>Convert a list into tuples of length tuple_length Args:     input_list (list): list with values to be converted into tuples     tuple_length (int): length of tuples in the list Returns:     (list): A list of tuples</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('totuples')\ndef totuples(input_list: list, tuple_length: int):\n    \"\"\"\n    Convert a list into tuples of length tuple_length\n    Args:\n        input_list (list): list with values to be converted into tuples\n        tuple_length (int): length of tuples in the list\n    Returns:\n        (list): A list of tuples\n    \"\"\"\n    # if not evenly divisible by tuple_length excess values are discarded\n    return list(zip(*[iter(input_list)]*tuple_length))\n</code></pre>"},{"location":"filters/#encodingformatting-filters","title":"Encoding/Formatting Filters","text":""},{"location":"filters/#sandhill.filters.filters.commafy","title":"<code>commafy(value)</code>","text":"<p>Take a number and format with commas.</p> <p>Use: <code>1234567 | commafy</code> = <code>\"1,234,567\"</code> Args:     value (int): Integer value to comma format Returns:     (str): Comma-fied representation</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('commafy')\ndef commafy(value):\n    '''\n    Take a number and format with commas.\\n\n    Use: `1234567 | commafy` = `\"1,234,567\"`\n    Args:\n        value (int): Integer value to comma format\n    Returns:\n        (str): Comma-fied representation\n    '''\n    ret = \"\"\n    if isinstance(value, int):\n        ret = f\"{value:,}\"\n    return ret\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.formatbinary","title":"<code>formatbinary(value)</code>","text":"<p>Format bytes size to JEDEC standard binary file size.</p> <p>Use: <code>4096 | formatbinary</code> = <code>\"4 KB\"</code> </p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | int</code> <p>Number of bytes. </p> required <p>Returns:</p> Type Description <code>str</code> <p>The formatted bytesize or <code>0 B</code> on invalid input value.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('formatbinary')\ndef formatbinary(value):\n    \"\"\"\n    Format bytes size to JEDEC standard binary file size.\\n\n    Use: `4096 | formatbinary` = `\"4 KB\"` \\n\n    Args:\n        value (str|int): Number of bytes. \\n\n    Returns:\n        (str): The formatted bytesize or `0 B` on invalid input value. \\n\n    \"\"\"\n    suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']\n    i = 0\n    nbytes = int(value) if f\"{value}\".isdigit() else 0\n    while nbytes &gt;= 1024 and i &lt; len(suffixes)-1:\n        nbytes /= 1024\n        i += 1\n    fsize = f'{nbytes:.1f}'.rstrip('0').rstrip('.')\n    return f\"{fsize} {suffixes[i]}\"\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.formatedate","title":"<code>formatedate(value, default='Indefinite', add_days=1)</code>","text":"<p>Format the provided embargo end date as a human readable string. </p> <p>If the date year is 9999, it will show the default value. </p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>A date string in the format YYYY-MM-DD </p> required <code>default</code> <code>str</code> <p>The default string (Default: \"Indefinite\") </p> <code>'Indefinite'</code> <code>add_days</code> <code>int</code> <p>Number of days to add to the end date (Default: 1) </p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted end date</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('formatedate')\n@catch((ValueError, TypeError), return_arg=\"default\")\ndef formatedate(value, default=\"Indefinite\", add_days=1):\n    '''\n    Format the provided embargo end date as a human readable string. \\n\n    If the date year is 9999, it will show the default value. \\n\n    Args:\n        value (str): A date string in the format YYYY-MM-DD \\n\n        default (str): The default string (Default: \"Indefinite\") \\n\n        add_days (int): Number of days to add to the end date (Default: 1) \\n\n    Returns:\n        (str): Formatted end date \\n\n    '''\n    def day_suffix(dom):\n        return {1:\"st\", 2:\"nd\", 3:\"rd\"}.get(dom if dom &lt; 20 else dom%10, \"th\")\n\n    result = default\n    value_date = datetime.strptime(value, \"%Y-%m-%d\")\n    if value_date.year != 9999:\n        # Add in the additional day(s)\n        value_date += timedelta(days=add_days)\n        # Format the result\n        result = value_date.strftime(\"%B DAY %Y\")\n        # Add in the suffix (st, th, rd, nd)\n        result = result.replace(\"DAY\", f\"{value_date.day}{day_suffix(value_date.day)},\")\n    return result\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.unescape","title":"<code>unescape(value)</code>","text":"<p>Unescape special characters in a string of HTML.</p> <p>Use: <code>\"Moon &amp;amp; &amp;#42;&amp;#42;&amp;#42;\" | unescape</code> = <code>\"Moon &amp; ***\"</code> </p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The string to unescape. </p> required <p>Returns:</p> Type Description <code>str</code> <p>The unescaped string, or empty string if passed a non-string value.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('unescape')\ndef unescape(value):\n    \"\"\"\n    Unescape special characters in a string of HTML.\\n\n    Use: `\"Moon &amp;amp; &amp;#42;&amp;#42;&amp;#42;\" | unescape` = `\"Moon &amp; ***\"` \\n\n    Args:\n        value (str): The string to unescape. \\n\n    Returns:\n        (str): The unescaped string, or empty string if passed a non-string value. \\n\n    \"\"\"\n    return html.unescape(value) if isinstance(value, str) else \"\"\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.urlquote","title":"<code>urlquote(url_str)</code>","text":"<p>Fully escapes all characters (including slash) in the given string with URL percent escapes </p> <p>Parameters:</p> Name Type Description Default <code>url_str</code> <code>str</code> <p>The string to escape </p> required <p>Returns:</p> Type Description <code>str</code> <p>The fully escaped string</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('urlquote')\ndef urlquote(url_str):\n    \"\"\"\n    Fully escapes all characters (including slash) in the given string with URL percent escapes \\n\n    Args:\n        url_str (str): The string to escape \\n\n    Returns:\n        (str): The fully escaped string \\n\n    \"\"\"\n    return quote(url_str).replace('/', '%2F')\n</code></pre>"},{"location":"filters/#solr-filters","title":"Solr Filters","text":""},{"location":"filters/#sandhill.filters.filters.solr_addfq","title":"<code>solr_addfq(query: dict, field: str, value: str)</code>","text":"<p>Adds the field and value to the filter query.</p> <p>Also removes the <code>start</code> query param if it exists under the assumption that a user removing facets would want to return to the first page. Args:     query (dict): Solr query (e.g. <code>{\"q\": \"frogs\", \"fq\": \"dc.title:example_title\"}</code>)     field (str): field that needs to be checked in the filter query (e.g. <code>dc.creator</code>)     value (str): value that needs to be checked in the filter query (e.g. <code>example_creator</code>) Returns:     (dict): The updated query dict</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('solr_addfq')\ndef solr_addfq(query: dict, field: str, value: str):\n    \"\"\"\n    Adds the field and value to the filter query.\\n\n    Also removes the `start` query param if it exists under the\n    assumption that a user removing facets would want to return\n    to the first page.\n    Args:\n        query (dict): Solr query (e.g. `{\"q\": \"frogs\", \"fq\": \"dc.title:example_title\"}`)\n        field (str): field that needs to be checked in the filter query (e.g. `dc.creator`)\n        value (str): value that needs to be checked in the filter query (e.g. `example_creator`)\n    Returns:\n        (dict): The updated query dict\n    \"\"\"\n    if not 'fq' in query:\n        query['fq'] = []\n\n    if not isinstance(query['fq'], list):\n        query['fq'] = [query['fq']]\n\n    # TODO this only works when adding a fq value, but fails on an actual solr query\n    fquery = f\"{field}:{solr_encode(value)}\"\n    if fquery not in query['fq']:\n        query['fq'].append(fquery)\n\n    # removing the start query param when new filters are applied\n    if 'start' in query:\n        del query['start']\n\n    return query\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.solr_decode","title":"<code>solr_decode(value, escape_wildcards=False)</code>","text":"<p>Filter to decode a value previously encoded for Solr. </p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>string with Solr escapes to be decoded </p> required <code>escape_wildcards</code> <code>bool</code> <p>If Solr's wildcard indicators (* and ?)             should be encoded </p> <p>Default: <code>False</code> </p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>same string after being decoded</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('solr_decode')\ndef solr_decode(value, escape_wildcards=False):\n    \"\"\"Filter to decode a value previously encoded for Solr. \\n\n    Args:\n        value (str): string with Solr escapes to be decoded \\n\n        escape_wildcards (bool): If Solr's wildcard indicators (* and ?) \\\n            should be encoded \\n\n            Default: `False` \\n\n    Returns:\n        (str): same string after being decoded \\n\n    \"\"\"\n    if isinstance(value, str):\n        value = Solr().decode_value(value, escape_wildcards)\n    return value\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.solr_encode","title":"<code>solr_encode(value, escape_wildcards=False, preserve_quotes=False)</code>","text":"<p>Filter to encode a value being passed to Solr </p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>string to escape Solr characters </p> required <code>escape_wildcards</code> <code>bool</code> <p>If Solr's wildcard indicators (* and ?)             should be encoded </p> <p>Default: <code>False</code> </p> <code>False</code> <code>preserve_quotes</code> <code>bool</code> <p>If set to True, will prevent quotes on outside             of the string from being encoded </p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>same string but with Solr characters encoded</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('solr_encode')\ndef solr_encode(value, escape_wildcards=False, preserve_quotes=False):\n    \"\"\"Filter to encode a value being passed to Solr \\n\n    Args:\n        value (str): string to escape Solr characters \\n\n        escape_wildcards (bool): If Solr's wildcard indicators (* and ?) \\\n            should be encoded \\n\n            Default: `False` \\n\n        preserve_quotes (bool): If set to True, will prevent quotes on outside \\\n            of the string from being encoded \\n\n    Returns:\n        (str): same string but with Solr characters encoded \\n\n    \"\"\"\n    quotes_exist = False\n\n    if preserve_quotes and value.startswith('\"') and value.endswith('\"'):\n        value = value.strip('\"')\n        quotes_exist = True\n\n    if isinstance(value, str):\n        value = Solr().encode_value(value, escape_wildcards)\n\n    if quotes_exist:\n        value = f\"\\\"{value}\\\"\"\n\n    return value\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.solr_encodequery","title":"<code>solr_encodequery(query, escape_wildcards=False)</code>","text":"<p>Parses and encode a Solr query arguments (the part after the colon). </p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Solr query argument to encode. </p> required <code>escape_wildcards</code> <code>bool</code> <p>If Solr's wildcard indicators (* and ?)                                  should be encoded (Default: False) </p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The Solr query with appropriate characters encoded.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('solr_encodequery')\ndef solr_encodequery(query, escape_wildcards=False):\n    \"\"\"\n    Parses and encode a Solr query arguments (the part after the colon). \\n\n    args:\n        query (str): Solr query argument to encode. \\n\n        escape_wildcards (bool): If Solr's wildcard indicators (* and ?) \\\n                                 should be encoded (Default: False) \\n\n    returns:\n        (str): The Solr query with appropriate characters encoded. \\n\n    \"\"\"\n    return Solr().encode_query(query, escape_wildcards=escape_wildcards)\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.solr_getfq","title":"<code>solr_getfq(query: dict)</code>","text":"<p>Extract and returns the filter queries from a Solr query.</p> <p>Example input: </p> <pre><code>{\"q\":\"frogs\", \"fq\":[\"dc.title:example_title1\", \"dc.title:example_title2\",\n\"dc.creator:example_creator1\", \"dc.creator:example_creator2\"]}\n</code></pre> <p>Example output: </p> <pre><code>{\"dc.title\": [\"example_title1\", \"example_title2\"], \"dc.creator\":\n[\"example_creator1\", \"example_creator2\"]}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>dict</code> <p>A Solr query. </p> required <p>Returns:</p> Type Description <code>dict</code> <p>The extracted filter queries.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('solr_getfq')\ndef solr_getfq(query: dict):\n    \"\"\"\n    Extract and returns the filter queries from a Solr query.\\n\n    Example input: \\n\n    ```\n    {\"q\":\"frogs\", \"fq\":[\"dc.title:example_title1\", \"dc.title:example_title2\",\n    \"dc.creator:example_creator1\", \"dc.creator:example_creator2\"]}\n    ``` \\n\n    Example output: \\n\n    ```\n    {\"dc.title\": [\"example_title1\", \"example_title2\"], \"dc.creator\":\n    [\"example_creator1\", \"example_creator2\"]}\n    ``` \\n\n    Args:\n        query (dict): A Solr query. \\n\n    Returns:\n        (dict): The extracted filter queries. \\n\n    \"\"\"\n    def parse_fq_into_dict(fq_dict, fq_str):\n        fq_pair = fq_str.split(\":\", 1)\n        if len(fq_pair) != 2:\n            app.logger.debug(f\"Could not split invalid Solr fq: {fq_str}\")\n            return\n        if not fq_pair[0] in fq_dict:\n            fq_dict[fq_pair[0]] = []\n        fq_dict[fq_pair[0]].append(solr_decode(fq_pair[1]))\n\n    fqueries = {}\n    if 'fq' in query:\n        if isinstance(query['fq'], list):\n            for fquery in query['fq']:\n                parse_fq_into_dict(fqueries, fquery)\n        else:\n            parse_fq_into_dict(fqueries, query['fq'])\n    return fqueries\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.solr_hasfq","title":"<code>solr_hasfq(query: dict, field: str, value: str)</code>","text":"<p>Check if filter query has the given field and value. Args:     query (dict): Solr query (e.g. <code>{\"q\": \"frogs\", \"fq\": \"dc.title:example_title\"}</code>)     field (str): field that needs to be checked in the filter query (e.g. <code>dc.title</code>)     value (str): value that needs to be checked in the filter query (e.g. <code>example_title</code>) Returns:     (bool): True if the filter query was found.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('solr_hasfq')\ndef solr_hasfq(query: dict, field: str, value: str):\n    \"\"\"\n    Check if filter query has the given field and value.\n    Args:\n        query (dict): Solr query (e.g. `{\"q\": \"frogs\", \"fq\": \"dc.title:example_title\"}`)\n        field (str): field that needs to be checked in the filter query (e.g. `dc.title`)\n        value (str): value that needs to be checked in the filter query (e.g. `example_title`)\n    Returns:\n        (bool): True if the filter query was found.\n    \"\"\"\n    fqueries = [\n        ':'.join([field, solr_encode(value)]),\n        ':'.join([field, value])\n    ]\n\n    found = False\n    if 'fq' in query:\n        if not isinstance(query['fq'], list):\n            if query['fq'] in fqueries:\n                found = True\n        else:\n            for fquery in fqueries:\n                if fquery in query['fq']:\n                    found = True\n    return found\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.solr_removefq","title":"<code>solr_removefq(query: dict, field: str, value: str)</code>","text":"<p>Removes the filter query and returns the revised query. Also removes the 'start' query param if it exists under the assumption that a user removing facets would want to return to the first page. Args:     query (dict): Solr query (e.g. <code>{\"q\": \"frogs\", \"fq\": \"dc.title:example_title\"}</code>)     field (str): field that needs to be removed from the filter query (e.g. <code>dc.title</code>)     value (str): value that needs to be removed from the filter query (e.g. <code>example_title</code>) Returns:     (dict): The updated query dict</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('solr_removefq')\ndef solr_removefq(query: dict, field: str, value: str):\n    \"\"\"\n    Removes the filter query and returns the revised query.\n    Also removes the 'start' query param if it exists under the\n    assumption that a user removing facets would want to return\n    to the first page.\n    Args:\n        query (dict): Solr query (e.g. `{\"q\": \"frogs\", \"fq\": \"dc.title:example_title\"}`)\n        field (str): field that needs to be removed from the filter query (e.g. `dc.title`)\n        value (str): value that needs to be removed from the filter query (e.g. `example_title`)\n    Returns:\n        (dict): The updated query dict\n    \"\"\"\n    fqueries = [\n        ':'.join([field, solr_encode(value)]),\n        ':'.join([field, value])\n    ]\n\n    if 'fq' in query:\n        if not isinstance(query['fq'], list):\n            if query['fq'] in fqueries:\n                query['fq'] = []\n        else:\n            for fquery in fqueries:\n                if fquery in query['fq']:\n                    query['fq'].remove(fquery)\n\n    # removing the start query param when new filters are applied\n    if 'start' in query:\n        del query['start']\n\n    return query\n</code></pre>"},{"location":"filters/#specialty-filters","title":"Specialty Filters","text":""},{"location":"filters/#sandhill.filters.filters.assembleurl","title":"<code>assembleurl(urlcomponents)</code>","text":"<p>Take urlcomponents (derived from Flask Request object) and returns a url. </p> <p>Parameters:</p> Name Type Description Default <code>urlcomponents</code> <code>dict</code> <p>components of the URL to build </p> required <p>Returns:</p> Type Description <code>str</code> <p>fully combined URL with query arguments</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('assembleurl')\ndef assembleurl(urlcomponents):\n    \"\"\"\n    Take urlcomponents (derived from Flask Request object) and returns a url. \\n\n    Args:\n        urlcomponents (dict): components of the URL to build \\n\n    Returns:\n        (str): fully combined URL with query arguments \\n\n    \"\"\"\n    if not isinstance(urlcomponents, dict) or not (path := urlcomponents.get(\"path\")):\n        return \"\"\n\n    if \"query_args\" not in urlcomponents or not urlcomponents[\"query_args\"] \\\n      or not isinstance(urlcomponents[\"query_args\"], dict):\n        return path\n\n    query_string_parts = []\n    for key in urlcomponents[\"query_args\"]:\n        # Remove 'hidden' params\n        if not key.startswith('_'):\n            vals = urlcomponents['query_args'][key]\n            if not isinstance(vals, list):\n                vals = [vals]\n            for val in vals:\n                query_string_parts.append(f\"{quote(key)}={quote(str(val))}\")\n\n    return f\"{path}?{'&amp;'.join(query_string_parts)}\"\n</code></pre>"},{"location":"filters/#getconfig","title":"<code>getconfig()</code>","text":"<p>Get the value of the given config name. It will first check in the environment for the variable name, otherwise look in the app.config, otherwise use the default param Args:     name (str): Name of the config variable to look for     default (str): The defaut value if not found elsewhere Returns:     (str): Value of the config variable, default value otherwise</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('getconfig')\ndef filter_getconfig(name: str, default=None):\n    \"\"\"\n    Get the value of the given config name. It will first\n    check in the environment for the variable name, otherwise\n    look in the app.config, otherwise use the default param\n    Args:\n        name (str): Name of the config variable to look for\n        default (str): The defaut value if not found elsewhere\n    Returns:\n        (str): Value of the config variable, default value otherwise\n    \"\"\"\n    return getconfig(name, default)\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.filtertags","title":"<code>sandhill.filters.filters.filtertags(value, *args)</code>","text":"<p>Filter out all HTML tags except for the ones specified     and marks the output as safe to render.</p> <p>Use: <code>&lt;i&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;/i&gt; | filtertags('b')</code> = <code>&lt;b&gt;Hello&lt;/b&gt;</code> </p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>A string potentially containing HTML tags. </p> required <code>*args</code> <code>str</code> <p>Tag names which are safe and will not be removed. </p> <code>()</code> <p>Returns:</p> Type Description <code>str</code> <p>A string with tags removed (excluding those passed as *args). </p> <p>This string is marked <code>safe</code> and will not be further escaped by Jinja.</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('filtertags')\ndef filtertags(value, *args):\n    \"\"\"\n    Filter out all HTML tags except for the ones specified \\\n    and marks the output as safe to render.\\n\n    Use: `&lt;i&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;/i&gt; | filtertags('b')` = `&lt;b&gt;Hello&lt;/b&gt;` \\n\n    Args:\n        value (str): A string potentially containing HTML tags. \\n\n        *args (str): Tag names which are safe and will not be removed. \\n\n    Returns:\n        (str): A string with tags removed (excluding those passed as *args). \\n\n               This string is marked `safe` and will not be further escaped by Jinja. \\n\n    \"\"\"\n    htf = HTMLTagFilter(tags=args)\n    htf.feed(value)\n    return Markup(htf.output)\n</code></pre>"},{"location":"filters/#xpath","title":"<code>xpath()</code>","text":"<p>Perform an XPath query against an XML source Args:     value (str): XML source     xpath (str): An XPath query Returns:     (list): A list of matching lxml.etree._Elements</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('xpath')\ndef filter_xpath(value, xpath):\n    '''\n    Perform an XPath query against an XML source\n    Args:\n        value (str): XML source\n        xpath (str): An XPath query\n    Returns:\n        (list): A list of matching lxml.etree._Elements\n    '''\n    return xml.xpath(value, xpath)\n</code></pre>"},{"location":"filters/#xpath_by_id","title":"<code>xpath_by_id()</code>","text":"<p>Perform an XPath query against an XML source and returns matched elements as a dict, where the key is the 'id' attribute of the element and the value is the XML content inside the element as a string. Args:     value (str): XML source     xpath (str): An XPath query Returns:     (dict): A mapping of element 'id' to a string of XML for its children</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('xpath_by_id')\ndef filter_xpath_by_id(value, xpath):\n    '''\n    Perform an XPath query against an XML source and returns matched\n    elements as a dict, where the key is the 'id' attribute of the\n    element and the value is the XML content inside the element as a string.\n    Args:\n        value (str): XML source\n        xpath (str): An XPath query\n    Returns:\n        (dict): A mapping of element 'id' to a string of XML for its children\n    '''\n    return xml.xpath_by_id(value, xpath)\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.render","title":"<code>render(context, value, **kwargs)</code>","text":"<p>Renders a given string using Jinja. </p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Jinja2 context</code> <p>context information and variables to use when             evaluating the provided template string. Passed automatically. </p> required <code>value</code> <code>str</code> <p>Jinja2 template string to evaluate given the provided context. </p> required <code>**kwargs</code> <code>dict</code> <p>Additional key-value pairs to add to the render context. </p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>the rendered string</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('render')\n@pass_context\n@catch(TemplateError, \"Invalid template provided: {value}. Error: {exc}\", return_val=None)\n@catch(TypeError, \"Cannot render a non-string value: {value}. Error: {exc}\", return_val=None)\ndef render(context, value, **kwargs):\n    \"\"\"Renders a given string using Jinja. \\n\n    Args:\n        context (Jinja2 context): context information and variables to use when \\\n            evaluating the provided template string. Passed automatically. \\n\n        value (str): Jinja2 template string to evaluate given the provided context. \\n\n        **kwargs (dict): Additional key-value pairs to add to the render context. \\n\n    Returns:\n        (str): the rendered string \\n\n    \"\"\"\n    if kwargs:\n        kwargs.update(context)\n        ctx = kwargs\n    else:\n        ctx = context\n\n    data_template = context.environment.from_string(value)\n    return data_template.render(**ctx)\n</code></pre>"},{"location":"filters/#sandhill.filters.filters.renderliteral","title":"<code>renderliteral(context, value, fallback_to_str=True)</code>","text":"<p>Renders string via Jinja and attempts to perform a literal_eval on the result. </p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Jinja2 context</code> <p>context information and variables to use when             evaluating the provided template string. </p> required <code>value</code> <code>str</code> <p>Jinja2 template string to evaluate given the provided context </p> required <code>fallback_to_str</code> <code>bool</code> <p>If function should return string value on a failed             attempt to literal_eval </p> <code>True</code> <p>Returns:</p> Type Description <code>Any | None</code> <p>The literal_eval result, or string if fallback_to_str,         or None on render failure </p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If content is valid Python, but not a valid datatype </p> <code>SyntaxError</code> <p>If content is not valid Python</p> Source code in <code>sandhill/filters/filters.py</code> <pre><code>@app.template_filter('renderliteral')\n@pass_context\ndef renderliteral(context, value, fallback_to_str=True):\n    \"\"\"\n    Renders string via Jinja and attempts to perform a literal_eval on the result. \\n\n    Args:\n        context (Jinja2 context): context information and variables to use when \\\n            evaluating the provided template string. \\n\n        value (str): Jinja2 template string to evaluate given the provided context \\n\n        fallback_to_str (bool): If function should return string value on a failed \\\n            attempt to literal_eval \\n\n    Returns:\n        (Any|None): The literal_eval result, or string if fallback_to_str, \\\n        or None on render failure \\n\n    Raises:\n        ValueError: If content is valid Python, but not a valid datatype \\n\n        SyntaxError: If content is not valid Python \\n\n    \"\"\"\n    context.environment.autoescape = False\n    data_val = render(context, value)\n    if data_val:\n        try:\n            data_val = literal_eval(data_val)\n        except (ValueError, SyntaxError) as err:\n            app.logger.debug(f\"Could not literal eval {data_val}. Error: {err}\")\n            if not fallback_to_str:\n                raise err\n    context.environment.autoescape = True\n    return data_val\n</code></pre>"},{"location":"functional-testing/","title":"Functional Testing","text":"<p>Sandhill allows you to create automated testing of your site pages, allowing fast verification that your site is operating normally. Each test can verify any number of apects of page (or pages) to ensure they are in compliance.</p> <p>Basically, each test will perform an actual call to your instance of Sandhill and then perform verification checks on the response. What verification checks it does is entirely up to you.</p> <p>Entry of functional tests are maintained in a JSON file at: <pre><code>instance/config/testing/pages.json\n</code></pre></p>"},{"location":"functional-testing/#the-basics","title":"The Basics","text":"<p>Here would be a fairly simple <code>pages.json</code> file with 3 test entries: <pre><code>[\n    {\n        \"_comment\": \"Ensure main page loads\"\n        \"page\": \"/\",\n        \"code\": 200,\n        \"contains\": [\n            \"Welcome to my site!\"\n        ]\n    },\n    {\n        \"_comment\": \"Access to user profiles should be rejected unless authenticated\"\n        \"page\": \"/user/1/profile\",\n        \"code\": 401\n    },\n    {\n        \"_comment\": \"The order form should be empty by default\",\n        \"page\": \"/order/cart\",\n        \"code\": 200,\n        \"contains\": [\n            \"Your cart (0 items)\"\n        ],\n        \"excludes\": [\n            \"Remove from cart\",\n            \"Proceed to checkout\"\n        ]\n    }\n]\n</code></pre></p> <p>Breaking these tests down: * <code>_comment</code> Gives you a place to describe the purpose of the test. * <code>page</code> The relative page on your site to call and test against * <code>method</code> The method for the call; default <code>GET</code> * <code>code</code> The HTTP code the request to your page should return. * <code>contains</code> A list of strings that should exist in the source code returned for the page. * <code>excludes</code> A list of strings that should NOT exist in the source code returned from the page. * <code>control</code> A way to defining more advanced testing configurations, such as looping.</p> <p>For each page entry, all specified tests much succeed or the entire entry will fail.  </p> <p>To run all your functional tests, issue the command: <pre><code>INSTANCE_DIR=/opt/sandhill/instance /opt/sandhill/env/bin/pytest -m functional --no-cov\n</code></pre> Given that: * <code>/opt/sandhill/instance</code> is where your <code>instance</code> directory is located * <code>/opt/sandhill</code> is where Sandhill is installed.</p> <p>Of course, update these to match your setup.  </p> <p>If all goes well, the output would look like this: <pre><code>========================== test session starts =============================\nplatform linux -- Python 3.6.9, pytest-6.0.1, py-1.10.0, pluggy-0.13.1\nrootdir: /opt/sandhill, configfile: pytest.ini\nplugins: cov-2.10.0, mock-3.3.1\ncollected 85 items / 82 deselected / 3 selected\n\nsandhill/tests/test_pages.py ...                                      [100%]\n\n==================== 3 passed, 82 deselected in 32.11s =====================\n</code></pre></p> <p>You will see the 3 dots next to the <code>test_pages.py</code> entry along with 3 tests selected and 3 test passed. The other tests (82 in the example above) are unit tests used by Sandhill developers to test internal code. It's okay for those to be deselected.  </p> <p>That's the basics to get started. First create the <code>pages.json</code> file and then start adding tests to it. Keep reading if you'd like to learn about the more advanced capabilities available.  </p>"},{"location":"functional-testing/#advanced-usage","title":"Advanced Usage","text":"<p>JSON files located in <code>instance/testing/</code> will be loaded for testing. The root object must be a list, that is, an empty file would appear like: <pre><code>[]\n</code></pre></p> <p>Adding entries into list must follow a dict type format and may have the following keys:  </p> <p>_comment (Optional, String, Jinja Processed) This is just a freeform string field where you may add a description for the page test.  </p> <p>Examples: <code>\"_comment\": \"Check that all embargoed items cannot be downloaded\"</code> <code>\"_comment\": \"Verify disclaimer appears on all form pages\"</code> <code>\"_comment\": \"Checking asset links for {{ item.asset_id }}\"</code> </p> <p>page (String, Jinja Processed) This is the relative link on which the page test will occur. An actual call to this page happen as part of the test. If left blank, no page call will occur.  </p> <p>Examples: <code>\"page\": \"/node/aboutus\"</code> <code>\"page\": \"/asset/{{ item.asset_id }}/view\"</code></p> <p>method (String) The method to use for the test call, such as <code>GET</code>, <code>POST</code>, <code>DELETE</code>, etc. Case insensitive; defaults to <code>GET</code>.</p> <p>Examples: <code>\"method\": \"POST\"</code> <code>\"method\": \"patch\"</code></p> <p>code (Optional, Integer) The expected HTTP status code to receive as part of the response for the page call. Ignored if no <code>page</code> was set.  </p> <p>Examples: <code>\"code\": 200</code> <code>\"code\": 403</code></p> <p>contains (Optional, List, Jinja Processed) A list of strings that must exist in the source code returned from the <code>page</code> called. All entries must exist or the test will fail. Ignored if no <code>page</code> was set.  </p> <p>Examples: <pre><code>\"contains\": [\n    \"&lt;a href=\\\"#required\\\"&gt;Required Resources&lt;/a&gt;\",\n    \"Copyright &amp;copy; MySandhill\"\n]\n</code></pre> <pre><code>\"contains\": [\"Request a consultation on {{ record.description }}\"]\n</code></pre></p> <p>excludes (Optional, List, Jinja Processed) A list of strings that must NOT exist in the source code returned from the <code>page</code> called. None of the entries may exist or else the test will fail. Ignored if no <code>page</code> was set.  </p> <p>Examples: <pre><code>\"excludes\": [\n    \"/user/login\",\n    \"/asset/{{ item.asset_id }}/download\"\n]\n</code></pre> <pre><code>\"excludes\": [\"555-1234\"]\n</code></pre></p> <p>matches (Optional, List, Jinja Processed) A list of strings containing regular expressions that must match in the source code returned from the <code>page</code> called. All of the entry patterns much match or else the test will fail.  Ignored if no <code>page</code> was set.  </p> <p>Examples: <pre><code>\"matches\": [\n    \"Copyright Status:\\\\s+In Copyright\",\n    \"{{ user.fullname }}\\\\s+\\\\d{4}\"\n]\n</code></pre> <pre><code>\"matches\": [\"\\\\d{3}-\\\\d{4}\"]\n</code></pre></p> <p>control (Optional, Dict) The <code>control</code> part of a test entry defines supplimental JSON data calls to make which can be used in Jinja procesing, including during <code>evaluate</code> checks.  </p> <p>An example <code>control</code> section could look like: <pre><code>\"control\": {\n    \"loop\": \"item\",\n    \"item\": {\n        \"url\": \"{{ 'SOLR_URL' | getconfig }}/select?q=status:active&amp;fl=asset_id,title&amp;rows=999999\",\n        \"path\": \"$.response.docs[*]\"\n    },\n    \"child\": {\n        \"url\": \"{{ 'SOLR_URL' | getconfig }}/select?q=asset_id:{{ item.asset_id }}&amp;fl=asset_id,title&amp;rows=1\",\n        \"path\": \"$.response.docs[0]\"\n    }\n}\n</code></pre></p> <p>The only reserved key in a <code>control</code> section is <code>loop</code>. All other keys (<code>item</code>, <code>child</code> in the above example) are defined with a <code>url</code> and <code>path</code> to perform and parse a JSON call. For this documentation, these other keys will referred to as the variable <code>VAR</code>.  </p> <p>control[VAR] (Optional, Dict, Jinja Processed) Where <code>VAR</code> is any user defined string, the value must be a dict that defines another JSON API call to make and parse. Each <code>VAR</code> dict must have both <code>url</code> and <code>path</code> keys defined. There may be any number of <code>VAR</code> keys, which are processed in the order they are defined (unless a <code>control[loop]</code> is defined, in which the <code>VAR</code> indicated by the <code>loop</code> is always processed first.  </p> <p>The results of a <code>control[VAR]</code> call will be stored in the page entry using the <code>VAR</code> key. The response will be a list of matches, unless the response is indicated by <code>loop</code>, in which the <code>VAR</code> will be a single entry from the response, but there will be a new page entry for each entry in the response as well.  </p> <p>For example, this entry: <pre><code>{\n    \"page\": /asset/{{ item.asset_id }}\",\n    \"code\": 404,\n    \"control\": {\n        \"loop\": \"item\"\n        \"item\": {\n            \"url\": \"{{ 'SOLR_URL' | getconfig }}/select?q=status:disabled&amp;fl=asset_id,title&amp;rows=999999\",\n            \"path\": \"$.response.docs[*]\"\n        }\n    },\n    \"excludes\": [\"{{ item.title }}\"]\n}\n</code></pre></p> <p>Could result in a page entry to test for each record in <code>item</code>: <pre><code>{\n    \"page\": /asset/1\",\n    \"code\": 404,\n    \"item\": {\"asset_id\": 1, \"title\": \"My First Widget\"},\n    \"excludes\": [\"My First Widget\"]\n},\n{\n    \"page\": /asset/2\",\n    \"code\": 404,\n    \"item\": {\"asset_id\": 2, \"title\": \"My Second Widget\"},\n    \"excludes\": [\"My Second Widget\"]\n}\n... (and additional page tests for each record matched by \"item\" URL and path)\n</code></pre></p> <p><code>control[VAR][url]</code> (Optional, String, Jinja Processed) The <code>url</code> inside a <code>control[VAR]</code> dict defines a valid URL to call. The response must be in JSON format. The response is then queried by <code>path</code> to get a subset of the JSON.  </p> <p><code>control[VAR][path]</code> (Optional, String, Jinja Processed) A JSONPath query to parse the JSON response from <code>url</code> to select a subset of data. The results of this JSONPath query will be set into the page test entry under the key <code>VAR</code>.  </p> <p><code>control[loop]</code> (Optional, String) The <code>loop</code> key in <code>control</code> must have a value that indicates another <code>VAR</code> key in <code>control</code> which must also be defined. The response from this targeted <code>VAR</code> will be looped over, generating a new page test entry for each item in the target <code>VAR</code>.  </p> <p><code>evaluate</code> (Optional, List, Jinja Required) A list of strings that will be rendered by Jinja and then evaluated for truthiness. If the strings in the list are not wrapped by Jinja delimiters, the <code>{{</code> and <code>}}</code> delimiters will automatically be wrapped around the value. All entries must evaluate to a truthy value after having be Jinja processed or the test will fail. You must have set a <code>control</code> section in order to have data to evaluate on.  </p> <p>Values in an evaluate string are first parsed for JSONPath queries. Queries must begin with a root indictor <code>$</code>. If no context key is provided, it will query against the first data key available. To specify a JSONPath query to operate on a specific key, add the key name directly after the <code>$</code>, such as <code>$item.myquery</code>.  </p> <p>Examples: <pre><code>\"evaluate\": [\n    \"item.namespace == child[0].namespace\",\n    \"child[0].collection in item.collections\"\n    \"$item.response.numFound == $item.facet_counts.facet_fields.collection[1]\"\n</code></pre> <pre><code>\"evaluate\": [\"{{ page | lower == page }}\"]\n</code></pre></p>"},{"location":"functional-testing/#jinja-processing","title":"Jinja Processing","text":"<p>Any field that is Jinja processed has access to all filters and context processors from Sandhill. The context variables will be the entire page entry processed thus far.  </p> <p>Jinja processing occurs in steps, with each step having access to the data already processed in previous steps. Processing order is: * The <code>control[VAR]</code> indicated by <code>control[loop]</code>. * Each remaining <code>control[VAR]</code> in order of definition. * The entire page entry, minus the <code>evaluate</code> key. * The <code>evaluate</code> key (which occurs only during actual testing).</p>"},{"location":"functional-testing/#advanced-examples","title":"Advanced Examples","text":"<p>TODO</p>"},{"location":"functional-testing/#accessiblity-testing","title":"Accessiblity Testing","text":"<p>If you want to automcatically scan certain pages for accessibility violations, you can include those as part of your functional testing configuration.</p>"},{"location":"functional-testing/#running","title":"Running","text":"<p>Tests can be run by using the helper script included with this repository <code>run-pytest</code> with the <code>-a</code> flag for accessibility. <pre><code>./run-pytest -a\n</code></pre></p>"},{"location":"functional-testing/#configuration","title":"Configuration","text":"<p>Below is a sample entry for functional testing as seen earlier in this document. Notice now the added key for <code>a11y</code>. Additionally, you can provide an optional <code>disable</code> key which will ignore the provided list of Axe rules from the scan on that page.</p> <p>For a complete list of available rules to exclude see the official site. <pre><code>    {\n        \"_comment\": \"Ensure main page loads\"\n        \"page\": \"/\",\n        \"code\": 200,\n        \"contains\": [\n            \"Welcome to my site!\"\n        ],\n        \"axe\": {}\n    },\n    {\n        \"_comment\": \"Ensure second page loads\"\n        \"page\": \"/page 2\",\n        \"code\": 200,\n        \"contains\": [\n            \"Welcome to my page!\"\n        ],\n        \"axe\": {\n            \"disable\": [\"landmark-main-is-top-level\", \"landmark-one-main\"]\n        }\n    }\n</code></pre></p>"},{"location":"instance-setup/","title":"Instance Setup","text":""},{"location":"instance-setup/#what-is-an-instance","title":"What is an instance?","text":"<p>An instance is where you actually start developing your application. It contains all of the processing you might do as well as the design of your pages. All of these build upon the already included core Sandhill feature sets. Out of the box, Sandhill provides a range of data processors and Jinja2 template filters; but one has a simple \"It Works!\" template. It is up to you to develop everything in between to make your application have the feature set you desire! Think of it as Sandhill providing the core framework and your instance is your implementation of an application using that framework.</p>"},{"location":"instance-setup/#basic-structure-of-the-instance-directory","title":"Basic structure of the instance directory","text":"<p>All of the files in the below directories are dynamically loaded without additional configuration needed. None of these directories require files to be present for the site to load, but are used to add functionality to it.  </p> <p>instance/ \u251c\u2500\u2500 sandhill.cfg \u251c\u2500\u2500 bootstrap/ \u251c\u2500\u2500 commands/ \u251c\u2500\u2500 config/ \u2502\u00a0\u00a0 \u2514\u2500\u2500 routes/ \u251c\u2500\u2500 filters/ \u251c\u2500\u2500 static/ \u2514\u2500\u2500 templates/  </p>"},{"location":"instance-setup/#sandhillcfg","title":"<code>sandhill.cfg</code>","text":"<p>Configuration parameters can be passed either in a config file or via environment variables on the host machine. Environment variables either at the host level (in <code>/etc/environment</code>) or at the application level (in a  <code>.env</code> in the same directory as where the <code>instance/</code> directory is).  </p> <p>To see what default values will be used if none are passed, see the  sandhill.default_settings.cfg file in the <code>sandhill/</code> directory.  </p>"},{"location":"instance-setup/#bootstrap","title":"<code>bootstrap/</code>","text":"<p>Each file within this directory should contain code to be run at start-up.  </p> <p>For example: <code>instance/bootstrap/hi.py</code>: <pre><code>print(\"Bootstrap test\")\n</code></pre> Which would add \"Bootstrap test\" to the start-up logs. A real world example would be if you need to compile SCSS.  </p>"},{"location":"instance-setup/#commands","title":"<code>commands/</code>","text":"<p>This directory is used to include additional Click commands to your application.</p> <p>For example: <code>instance/commands/hi.py</code>: <pre><code>import click\nfrom sandhill import app\n\n@app.cli.command(\"hi\")\n@click.argument(\"name\")\ndef hi(name):\n    print(f\"Hi {name}!\")\n</code></pre> Would allow you to run: <pre><code>$ flask hi bob\nHi bob!\n</code></pre></p>"},{"location":"instance-setup/#configroutes","title":"<code>config/routes/</code>","text":"<p>A route defines a URL pattern that Sandhill will match. Any request to Sandhill that does not match a route will return a 404 page. Most routes are configured to render a  Jinja2 template (typically resulting in an HTML page), but can also return a stream of data (such as an image or downloadable file), or even use a processor built to return a response that doesn't conform to either of the above. See the  routes documentation for more details and examples.</p>"},{"location":"instance-setup/#filters","title":"<code>filters/</code>","text":"<p>Files within this directory are loaded to add  to the default set of filters already included in Sandhill.</p> <p>Each filter will be available to all templates used within the application.</p> <p>An example filter: <code>instance/filters/myfilter.py</code>: <pre><code>from sandhill import app\n\n@app.template_filter()\ndef islist(value):\n    \"\"\" Check if a value is a list \"\"\"\n    return isinstance(value, list)\n</code></pre></p> <p>Would provide the ability to do this in your template: <code>instance/templates/home.html.j2</code>: <pre><code>...\n&lt;p&gt;Is myvar a list? {{ myvar | is_list }}&lt;/p&gt;\n...\n</code></pre></p>"},{"location":"instance-setup/#processors","title":"<code>processors/</code>","text":"<p>Processors are what are called in the route configs to provide data or data processing before rendering a template or streaming output. For example if your home page requires you make a database call to get information for the page then you might have a <code>database</code> processor. See the data processors documentation for further details and examples.</p>"},{"location":"instance-setup/#static","title":"<code>static/</code>","text":"<p>This directory contains any static content used by your application, such as CSS or JS files.</p>"},{"location":"instance-setup/#templates","title":"<code>templates/</code>","text":"<p>The <code>templates</code> directory contains Jinja2 template files that can be referenced by your route configs. They have the ability to access the built-in or custom filters and all of the variables made available by your route configs (referenced by the <code>name</code> of the data item). Refer to the examples within the routes documentation to see the available variables.</p> <p>You can see the default included template to start with, but see Jinja2 documentation for the full range of options.</p>"},{"location":"routes/","title":"Routes in Sandhill","text":"<p>Sandhill processes page requests by looking at the path provided in the URL. The path of the URL is the part between the hostname and the arguments.</p> <p>For example, with the URL: <pre><code>https://example.edu/collection/42?sort=desc\n</code></pre></p> <p>The path would be: <code>/collection/42</code></p> <p>If Sandhill has a route defined that matches a requested path, it would proceed to render the appropriate page based on the defined route.</p>"},{"location":"routes/#defining-a-route","title":"Defining a Route","text":"<p>Routes are defined as JSON files inside your instance directory (see the guide on setting up your Sandhill instance). Specifically, route files should be placed in <code>instance/config/routes/</code>. Sandhill will automatically load all <code>.json</code> files placed here when it starts.</p>"},{"location":"routes/#a-simple-example","title":"A Simple Example","text":"<p>A simple example route file might look like this: instance/config/routes/simple.json<pre><code>{\n    \"routes\": [\n        \"/collections/\",\n        \"/browse/\"\n    ],\n    \"template\": \"collections.html\"\n}\n</code></pre></p> <p>In the above definition, going to either URL for your site: <pre><code>https://example.edu/collections/\nhttps://example.edu/browse/\n</code></pre></p> <p>Would serve up the <code>collections.html</code> file from your instance templates directory. Per the standard setup, all HTML templates should be placed in <code>instance/templates/</code>.</p> <p>Route definitions follow the Flask routing mechanics. Flask is the framework which underpins Sandhill.</p>"},{"location":"routes/#variables-in-route-path","title":"Variables in Route Path","text":"<p>This supports putting variables into the path such as <code>/collections/&lt;int:collection_id&gt;/</code> which can be referenced while the page is processing. In Sandhill, these path arguments are made available by the <code>view_args</code> variable; in such that <code>view_args.collection_id</code> would be the value <code>42</code> if the path was <code>/collections/42/</code>.</p> <p>Flask provides the following variable types:</p> type example path description <code>string</code> <code>/list/&lt;string:namespace&gt;/</code> Any string of text without slashes (<code>/</code>) <code>int</code> <code>/db/&lt;int:db&gt;/row/&lt;int:row&gt;</code> Positive integer values <code>float</code> <code>/round/&lt;float:num&gt;</code> Positive decimal values <code>path</code> <code>/dir/&lt;path:subdir&gt;</code> Any string, including slashes (<code>/</code>) <code>uuid</code> <code>/account/&lt;uuid:account&gt;/</code> A Universally unique identifier string"},{"location":"routes/#route-with-data-processors","title":"Route with Data Processors","text":"<p>A core feature of Sandhill is how it handles loading additional data while it processes a route. These additional actions are defined in the same route file and call upon Sandhill data processors to perform specific actions.</p> <p>A data processor can load dynamic data from a datastore or manipulate already loaded data to prepare it for output to the user.</p> <p>Sandhill comes with a number of builtin data processors that can be used immediately, though with some knowledge of Python programming you can also define your own data processors.</p>"},{"location":"routes/#example-with-a-data-processor","title":"Example with a Data Processor","text":"<p>Here's a basic route which uses a data processor to query a Solr service and retrieve a record: <pre><code>{\n    \"route\": [\n        \"/hello/&lt;int:user_id&gt;\"\n    ],\n    \"methods\": [\"GET\", \"POST\"],\n    \"template\": \"hello.html.j2\",\n    \"data\": [\n        {\n            \"name\": \"user\",\n            \"processor\": \"solr.select_record\",\n            \"params\": { \"q\": \"user_id:{{ view_args.user_id }}\" }\n        }\n    ]\n}\n</code></pre></p> <p>With the HTML template file containing Jinja2 syntax: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello to {{ user.firstname }} {{ user.lastname }}!&lt;/h1&gt;\n    &lt;p&gt;{{ user.firstname }}'s user_id is {{ user.user_id }}.&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <p>A request to <code>https://example.edu/hello/33</code> might produce and response like: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello to Aaron Zahn!&lt;/h1&gt;\n    &lt;p&gt;Aaron's user_id is 33.&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <p>In this case, the <code>solr.select_record</code> data processor automatically pulls the appropriate Solr API base URL from either the <code>instance/sandhill.cfg</code> file or from an environment variable, both named <code>SOLR_URL</code>. More details on the <code>solr</code> data processor is available in the data processor documentation and details on how to configure Sandhill is available in the instance setup documentation.</p>"},{"location":"routes/#jinja-templating","title":"Jinja Templating","text":"<p>Regarding the HTML template, Sandhill makes full use of the Jinja2 templating engine for rendering pages.</p> <p>It's not just HTML templates that are Jinja processed. Data processor definitions in the route config files are Jinja rendered as well. So the following is possible: <pre><code>{\n    \"route\": [\n        \"/&lt;string:namespace&gt;/&lt;int:id&gt;\"\n    ],\n    \"template\": \"record.html.j2\",\n    \"data\": [\n        {\n            \"name\": \"record\",\n            \"processor\": \"solr.select_record\",\n            \"params\": { \"q\": \"rec:{{ view_args.namespace }}-{{ view_args.id }}\" }\n        },\n        {\n            \"name\": \"parent\",\n            \"processor\": \"solr.select_record\",\n            \"params\": { \"q\": \"rec:{{ record.parent_rec }}\" }\n        }\n    ]\n}\n</code></pre></p> <p>Notice how use of Jinja is available in the JSON <code>data</code> section. Jinja expressions are rendered on a per request basis. Sandhill always provides the <code>view_args</code> variable for use of route path variables. Beyond that, any variables defined by a data processor also becomes available after that processor has run.</p> <p>In the previous example, notice how the second data processor is referencing the result of the first data processor (i.e. <code>record</code>).</p> <p>This is possible because data processor definitions are rendered in Sandhill sequentially. Each data processor is able to make use of data created by the processors defined before it.</p> <p>Mixing Jinja and JSON</p> <p>If use of Jinja expressions results in invalid JSON, the route will become unparsable. Be careful when using Jinja in JSON and ensure your output is JSON compatible. If your route is failing to load, be sure to check the Sandhill logs.</p>"},{"location":"routes/#advanced-examples","title":"Advanced Examples","text":""},{"location":"routes/#conditional-data-processors-and-implied-template","title":"Conditional Data Processors and Implied Template","text":"<p>Here is a more advanced route example that shows how you can use the  <code>when</code> attribute. </p> <p><pre><code>{\n    \"route\": [\n        \"/item/&lt;int:id&gt;\"\n    ],\n    \"data\": [\n        {\n            \"name\": \"render-id1\",\n            \"processor\": \"template.render\",\n            \"file\": \"item1.html.j2\",\n            \"when\": \"{{ view_args.id == 1 }}\"\n        },\n        {\n            \"name\": \"render\",\n            \"processor\": \"template.render\",\n            \"file\": \"item.html.j2\"\n        }\n    ]\n}\n</code></pre> In this example, notice that there is no <code>template</code> attribute provided. When a data processor returns a FlaskResponse or WerkzeugReponse, Sandhill will stop processing any further data processors and return that response immediately. In fact, specifying the <code>template</code> attribute is really just a shorthand method of appending the <code>template.render</code> processor as seen above.</p> <p>The <code>when</code> condition in the example is showing how you can conditionally have a data processor excluded from running when a page is loaded if the <code>when</code> condition is <code>True</code>. In this case the condition is based on one of the route URL variables (<code>view_args.id</code>), but all loaded data is available. A <code>when</code> is considered <code>True</code> if the value would be considered true when evaluated in Python.</p>"},{"location":"routes/#error-handling","title":"Error Handling","text":"<p>By default, Sandhill will not stop processing a request if a data processor fails or returns no data. When this is not desired, the <code>on_fail</code> may be set for any given data processor.</p> <p>Setting the <code>on_fail</code> to a HTTP status code integer will cause Sandhill to abort with that code should that data processor fail to return any data. <pre><code>{\n    \"route\": [\n        \"/item/&lt;int:id&gt;\"\n    ],\n    \"template\": \"record.html.j2\",\n    \"data\": [\n        {\n            \"name\": \"record\",\n            \"processor\": \"solr.select_record\",\n            \"params\": { \"q\": \"ID:{{ view_args.id }}\" },\n            \"on_fail\": 404\n        }\n    ]\n}\n</code></pre></p> <p>With the above configuration, if the call to Solr fails for any reason, a 404 error will be returned and the abort template will be displayed instead. When the <code>on_fail</code> is not set and a failure occurs in a data processor, those errors are simply recorded in the logs and the next processor is loaded. Setting this attribute allows more fine-grained control over what processors are critical to a page loading and what error is appropriate for those errors.</p> <p>Some data processors have the ability to return the HTTP code of its choice. For example, if the data processor is making an external API call and you'd prefer it to pass back the HTTP code from the API call on failure. If the data processor supports it, setting <code>on_fail</code> to <code>0</code> will accomplish this. The <code>0</code> value indicates that Sandhill should abort page processing on a failure, but leave the selection of HTTP code up to the data processor.</p>"},{"location":"routes/#route-config-attributes","title":"Route Config Attributes","text":"<p>This section contains a summary of the available attributes for route definitions for quick reference. But more details on any of these attributes are found above. For full details on the <code>data</code> section, see the data processors documentation.</p> Name Type Description <code>route</code>/<code>routes</code> string, or list of strings The URL pattern to match in order for this route to be selected. Both names accept either string or list. <code>method</code>/<code>methods</code> string, or list of strings The request method to permit (e.g. <code>GET</code> or <code>POST</code>); default <code>GET</code>. Both names accept either string or list. <code>template</code> string, optional The name of the Jinja2 template file to attempt to render <code>data</code> list of JSON entries, optional An ordered list of data processors, with each one being run in order"},{"location":"service-setup/","title":"Service Setup","text":""},{"location":"service-setup/#create-the-service","title":"Create the service","text":"<p>If you are running on a Linux environment, you can have Sandhill automatically start on boot by having it defined as a service. Copy the sample systemd unit file and be sure to make any local changes to it required for your environment (such as the <code>EnvironmentFile</code> or <code>WorkingDirectory</code>).</p> <pre><code># For UWSGI setup\ncp etc/systemd/system/sandhill.service /etc/systemd/system/sandhill.service\n# Not required for Docker Swarm\n\n# Enable and start the service\nsystemctl daemon-reload\nsystemctl enable sandhill\nsystemctl start sandhill\n</code></pre>"},{"location":"service-setup/#create-the-rsyslog-config-optional","title":"Create the rsyslog config (optional)","text":"<p>This step is required if you want to have logging for this application go to a file other than syslog when running it as a service. This is only because <code>StandardOutput</code> and <code>StandardError</code> support file redirection in only the very recent versions of systemd.</p> <pre><code>cp etc/rsyslog.d/sandhill.conf /etc/rsyslog.d/\nmkdir -p /var/log/sandhill\nchown -R syslog:adm /var/log/sandhill\nsystemctl restart rsyslog\n</code></pre>"},{"location":"service-setup/#docker-configuration","title":"Docker Configuration:","text":"<p>In order to pass custom configurations to the Docker container, you will need to pass it environment values. You can either pass them directly to the docker command (<code>DEBUG=1 docker-compose up</code>) or provide them in an environment file, <code>./.env</code>. See Docker's documentation about the environment file. </p> <p>There are some default environment variable settings in sandhill/sandhill.default_settings.cfg; using the same variable names in the environment file will allow you to override those. </p>"},{"location":"service-setup/#configuring-email-for-docker-optional","title":"Configuring email for Docker (optional):","text":"<p>Sandhill has the ability to send emails based on a given error level.</p> <p>If you wish to do this, and have included the relevant email variables in the environment step above, you may still need to configure your server in order to send emails from it. This includes installing an email server such as postfix.</p> <p>For example, if you're using postfix, you would need to edit<code>/etc/postfix/main.cf</code> and update the <code>mynetworks</code> line to include the docker network's IP range: <pre><code>mynetworks = [existing line contents] 192.168.0.0/16\n</code></pre></p> <p>and then restart postfix: <pre><code>systemctl restart postfix\n</code></pre></p>"}]}